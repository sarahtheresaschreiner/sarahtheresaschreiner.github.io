{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Wissensverzeichnis","text":""},{"location":"index.html#markdown-cheat-sheet","title":"Markdown Cheat Sheet","text":"<p>View the Markdown Cheat Sheet</p>"},{"location":"markdown-cheat-sheet.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"markdown-cheat-sheet.html#commands","title":"Commands","text":"<ul> <li><code>python -m mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>python -m mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>python -m mkdocs build</code> - Build the documentation site.</li> <li><code>python -m mkdocs -h</code> - Print help message and exit.</li> </ul> <pre><code>---\nhide:\n  - navigation\n  - toc\n---\n</code></pre>"},{"location":"markdown-cheat-sheet.html#markdown-cheat-sheet","title":"Markdown Cheat Sheet","text":"<p>Thanks for visiting The Markdown Guide!</p> <p>This Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can\u2019t cover every edge case, so if you need more information about any of these elements, refer to the reference guides for basic syntax and extended syntax.</p>"},{"location":"markdown-cheat-sheet.html#basic-syntax","title":"Basic Syntax","text":"<p>These are the elements outlined in John Gruber\u2019s original design document. All Markdown applications support these elements.</p>"},{"location":"markdown-cheat-sheet.html#heading","title":"Heading","text":""},{"location":"markdown-cheat-sheet.html#h1","title":"H1","text":""},{"location":"markdown-cheat-sheet.html#h2","title":"H2","text":""},{"location":"markdown-cheat-sheet.html#h3","title":"H3","text":""},{"location":"markdown-cheat-sheet.html#bold","title":"Bold","text":"<p>bold text</p>"},{"location":"markdown-cheat-sheet.html#italic","title":"Italic","text":"<p>italicized text</p>"},{"location":"markdown-cheat-sheet.html#blockquote","title":"Blockquote","text":"<p>blockquote</p>"},{"location":"markdown-cheat-sheet.html#ordered-list","title":"Ordered List","text":"<ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"markdown-cheat-sheet.html#unordered-list","title":"Unordered List","text":"<ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul>"},{"location":"markdown-cheat-sheet.html#code","title":"Code","text":"<p><code>code</code></p>"},{"location":"markdown-cheat-sheet.html#horizontal-rule","title":"Horizontal Rule","text":""},{"location":"markdown-cheat-sheet.html#link","title":"Link","text":"<p>Markdown Guide</p>"},{"location":"markdown-cheat-sheet.html#image","title":"Image","text":""},{"location":"markdown-cheat-sheet.html#extended-syntax","title":"Extended Syntax","text":"<p>These elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.</p>"},{"location":"markdown-cheat-sheet.html#table","title":"Table","text":"Syntax Description Header Title Paragraph Text"},{"location":"markdown-cheat-sheet.html#fenced-code-block","title":"Fenced Code Block","text":"<pre><code>{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25\n}\n</code></pre>"},{"location":"markdown-cheat-sheet.html#footnote","title":"Footnote","text":"<p>Here's a sentence with a footnote. [^1]</p> <p>[^1]: This is the footnote.</p>"},{"location":"markdown-cheat-sheet.html#heading-id","title":"Heading ID","text":""},{"location":"markdown-cheat-sheet.html#my-great-heading-custom-id","title":"My Great Heading {#custom-id}","text":""},{"location":"markdown-cheat-sheet.html#definition-list","title":"Definition List","text":"<p>term : definition</p>"},{"location":"markdown-cheat-sheet.html#strikethrough","title":"Strikethrough","text":"<p>~~The world is flat.~~</p>"},{"location":"markdown-cheat-sheet.html#task-list","title":"Task List","text":"<ul> <li>[x] Write the press release</li> <li>[ ] Update the website</li> <li>[ ] Contact the media</li> </ul>"},{"location":"markdown-cheat-sheet.html#emoji","title":"Emoji","text":"<p>That is so funny! :joy:</p> <p>(See also Copying and Pasting Emoji)</p>"},{"location":"markdown-cheat-sheet.html#highlight","title":"Highlight","text":"<p>I need to highlight these ==very important words==.</p>"},{"location":"markdown-cheat-sheet.html#subscript","title":"Subscript","text":"<p>H~2~O</p>"},{"location":"markdown-cheat-sheet.html#superscript","title":"Superscript","text":"<p>X^2^</p>"},{"location":"Data%20Science/DSA/index.html","title":"Data Structures and Algorithms","text":"<p>This section covers fundamental data structures and algorithms that are essential for efficient programming and problem-solving. Ressources</p>"},{"location":"Data%20Science/DSA/index.html#big-o-notation","title":"Big O Notation","text":"<p>Big O notation is used to describe the performance or complexity of an algorithm. It provides the worst case time or space requirements in terms of the input size. More about Big O Notation</p>"},{"location":"Data%20Science/DSA/index.html#structures","title":"Structures","text":""},{"location":"Data%20Science/DSA/index.html#inplace","title":"Inplace?","text":"<p>In computer science, an in-place algorithm is an algorithm that operates directly on the input data structure without requiring extra space proportional to the input size. In other words, it modifies the input in place, without creating a separate copy of the data structure.</p>"},{"location":"Data%20Science/DSA/index.html#sets-and-sequences","title":"Sets and Sequences","text":"<ul> <li>A Set is an unordered collection of unique elements.  </li> <li>No duplicates allowed  </li> <li>Efficient for membership tests and set operations (union, intersection, difference)  </li> <li>A Sequence is an ordered collection of elements.  </li> <li>Duplicates allowed  </li> <li>Supports indexing, slicing, and iteration  </li> <li>Examples: lists, tuples, strings</li> </ul>"},{"location":"Data%20Science/DSA/index.html#array","title":"Array","text":"<p>Arrays are a collection of items stored at contiguous memory locations. They allow for efficient indexing and iteration. However, their size is fixed upon creation, so adding o r removing elements can be costly in terms of time complexity. More about Arrays</p>"},{"location":"Data%20Science/DSA/index.html#linked-list","title":"Linked List","text":"<p>Linked Lists are a linear data structure where each element (node) contains a reference (link) to the next node in the sequence. This allows for dynamic memory allocation and efficient insertions and deletions. However, accessing elements by index is slower compared to arrays. More about Linked Lists</p>"},{"location":"Data%20Science/DSA/index.html#stacks-and-queues","title":"Stacks and Queues","text":"<p>Stacks are a linear data structure that follows the Last In First Out (LIFO) principle, where the last element added is the first one to be removed. Common operations include push (add an element) and pop (remove the top element). You can picture it like a stack of pancakes, where you can only access the first one. Queues are a linear data structure that follows the First In First Out (FIFO) principle, where the first element added is the first one to be removed. Common operations include enqueue (add an element to the back) and dequeue (remove the front element). You can picture it like a line of people waiting, where the first person in line is the first to be served. Deques (Double-Ended Queues) are a more versatile version of queues that allow adding and removing elements from both ends. This makes them suitable for scenarios where you need to efficiently manage elements at both the front and back of the collection. More about Stacks and Queues</p>"},{"location":"Data%20Science/DSA/index.html#dictionaries","title":"Dictionaries","text":"<p>Dictionaries, also known as hash maps or associative arrays, are data structures that store key-value pairs. They provide efficient lookups, insertions, and deletions based on keys. The average time complexity for these operations is O(1), making dictionaries a powerful tool for managing data that requires quick access. More about Dictionaries</p>"},{"location":"Data%20Science/DSA/index.html#hash-tables","title":"Hash Tables","text":"<p>A Hash Table is a data structure that implements an associative array, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. This allows for average-case constant time complexity O(1) for lookups, insertions, and deletions. However, in the worst case (e.g., many collisions), these operations can degrade to O(n). Hash tables are widely used in various applications, including databases and caching mechanisms. More about Hash Tables</p>"},{"location":"Data%20Science/DSA/index.html#trees","title":"Trees","text":"<p>Trees are a linear data structure. It is a collection of nodes connected by edges. Each tree has a root node (has no parents/referenes), and every node can have zero or more child nodes. Nodes with no children are called leaf nodes. Trees are used to represent hierarchical data and support efficient searching, insertion, and deletion operations. There can only be one path between any two nodes in a tree. Kinds of trees:</p> <ul> <li>Binary Trees</li> <li>AVL Trees</li> <li>Heaps</li> <li>Tries</li> </ul>"},{"location":"Data%20Science/DSA/index.html#trees-vs-graphs","title":"Trees vs Graphs","text":"<p>Tree is a restricted type of Graph Data Structure, just with some more rules. Every tree will always be a graph but not all graphs will be trees. Linked List, Trees, and Heaps all are special cases of Trees. \"In a tree there can't be more than one reference to the same object!\"</p>"},{"location":"Data%20Science/DSA/index.html#graphs","title":"Graphs","text":"<p>Graphs are a non-linear data structure. It consists of a set of vertices (or nodes) and a set of edges that connect pairs of vertices. Graphs can be used to represent various real-world systems, such as social networks, transportation networks, and communication networks. Graphs can be classified into:</p> <ul> <li>Directed Graphs (Digraphs): where edges have a direction, indicating a one-way relationship between vertices.</li> <li>Undirected Graphs: where edges do not have a direction, indicating a two-way relationship between vertices. More about Graphs</li> </ul> <p>View also:</p> <ul> <li>Breadth-First Search (BFS)</li> <li>Depth-First Search (DFS)</li> <li>Dijkstra</li> <li>Bellmann-Ford</li> </ul>"},{"location":"Data%20Science/DSA/index.html#algorithms","title":"Algorithms","text":""},{"location":"Data%20Science/DSA/index.html#sorting-algorithms","title":"Sorting Algorithms","text":"Name Time Complexity (Best) Time Complexity (Average) Time Complexity (Worst) Space Complexity Use Case Bubble Sort O(n) O(n\u00b2) O(n\u00b2) O(1) Simple to implement; educational purposes; nearly sorted small lists Selection Sort O(n\u00b2) O(n\u00b2) O(n\u00b2) O(1) When memory is limited; minimal swaps; small datasets Insertion Sort O(n) O(n\u00b2) O(n\u00b2) O(1) Efficient for small or nearly sorted datasets Merge Sort O(n log n) O(n log n) O(n log n) O(n) Stable sort; large datasets; linked lists Quick Sort O(n log n) O(n log n) O(n\u00b2) O(log n) Fast in practice; widely used; good average-case performance Bucket Sort O(n + k) O(n + k) O(n\u00b2) O(n + k) Input uniformly distributed over a known range Counting Sort O(n + k) O(n + k) O(n + k) O(k) Integers in a limited range; stable; fast non-comparison sort Radix Sort O(n*k) O(n*k) O(n*k) O(n + k) Sorting integers or strings with fixed digit/length; stable Heap Sort O(n log n) O(n log n) O(n log n) O(1) In-place sorting; large datasets; not stable <p>Notes:</p> <ul> <li><code>n</code> = number of elements</li> <li><code>k</code> = range of input values (for Counting/Bucket/Radix)</li> <li><code>Heap Sort</code> is not stable but works in-place</li> <li><code>Radix Sort</code> depends on the number of digits (<code>k</code>) in the elements</li> </ul>"},{"location":"Data%20Science/DSA/index.html#searching-algorithms","title":"Searching Algorithms","text":"Name Time Complexity (Best) Time Complexity (Average) Time Complexity (Worst) Space Complexity Use Case Linear Search O(1) O(n) O(n) O(1) Simple lists; unsorted arrays; small datasets Binary Search O(1) O(log n) O(log n) O(1) (iterative) / O(log n) (recursive) Sorted arrays; fast lookups; large datasets Ternary Search O(1) O(log\u2083 n) O(log\u2083 n) O(1) (iterative) / O(log\u2083 n) (recursive) Sorted arrays; unimodal functions; optimization problems Jump Search O(1) O(\u221an) O(\u221an) O(1) Sorted arrays; when linear search is too slow; medium-sized datasets Exponential Search O(1) O(log n) O(log n) O(1) Sorted arrays; when the element is near the beginning; works well with unbounded arrays"},{"location":"Data%20Science/DSA/index.html#string-manipulation-algorithms","title":"String Manipulation Algorithms","text":"<p>Examples and Details description of string manipulation algorithms. Kinds of string manipulation algorithms:</p> <ul> <li>Reversing a string</li> <li>Reversing a word</li> <li>Rotations</li> <li>Removing duplicates</li> <li>Anagrams</li> <li>Palindroms</li> <li>Most repeated character</li> </ul>"},{"location":"Data%20Science/DSA/index.html#recursion","title":"Recursion","text":"<p>More about Recursion</p>"},{"location":"Data%20Science/DSA/index.html#ressources","title":"Ressources","text":"<ul> <li>Big O Cheat Sheet</li> <li>Data Structures and Algorithms by CS  Dojo YouTube Playlist</li> <li>MIT 6.006 Introduction to Algorithms, Spring 2020</li> <li>Github - The Algorithms: Data Structures and Algorithms in Python</li> </ul>"},{"location":"Data%20Science/DSA/arrays.html","title":"Arrays","text":"<p>04.11.2025 An array is a data structure used to store multiple elements of the same data type in a single variable. Arrays allow indexed access to each element and provide an efficient way to organize and manipulate collections of data. The size of a basic (static) array is fixed once it is created.</p>"},{"location":"Data%20Science/DSA/arrays.html#static-arrays","title":"Static Arrays","text":"<ul> <li>The simplest form of arrays \u2014 fixed in size</li> <li>Elements are stored contiguously in memory</li> <li>Each element can be accessed using an index (starting at 0)</li> </ul>"},{"location":"Data%20Science/DSA/arrays.html#example","title":"Example","text":"<pre><code>arr = [10, 20, 30, 40, 50]\nprint(arr[2])     # Output: 30\n</code></pre>"},{"location":"Data%20Science/DSA/arrays.html#characteristics","title":"Characteristics","text":"<ul> <li>Fast random access \u2192 O(1)</li> <li>Insertion or deletion can be costly because elements must be shifted</li> <li>Memory allocated contiguously, which makes it efficient but inflexible in size</li> </ul>"},{"location":"Data%20Science/DSA/arrays.html#dynamic-arrays","title":"Dynamic Arrays","text":"<p>A Dynamic Array (e.g., <code>ArrayList</code> in Java or <code>list</code> in Python) automatically resizes when elements are added or removed. When the internal storage is full, a new larger array is created, and all elements are copied into it.</p>"},{"location":"Data%20Science/DSA/arrays.html#memory","title":"Memory","text":"<ul> <li>Internally store a reference to a static array</li> <li>When capacity is exceeded:</li> <li>A new array (typically 2\u00d7 the old size) is created</li> <li>All elements are copied to the new array</li> <li>The old array is freed from memory</li> </ul>"},{"location":"Data%20Science/DSA/arrays.html#example-python-list","title":"Example (Python List)","text":"<pre><code>arr = [1, 2, 3]\narr.append(4)       # adds element dynamically\narr.remove(2)       # removes element\nprint(arr)          # Output: [1, 3, 4]\n</code></pre>"},{"location":"Data%20Science/DSA/arrays.html#example-java-arraylist","title":"Example (Java ArrayList)","text":"<pre><code>import java.util.ArrayList;\n\nArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\narr.add(10);\narr.add(20);\narr.remove(0);\nSystem.out.println(arr);   // Output: [20]\n</code></pre>"},{"location":"Data%20Science/DSA/arrays.html#characteristics-dynamik-array","title":"Characteristics Dynamik Array","text":"<ul> <li>Resizable \u2014 grows automatically when more space is needed</li> <li>Slightly slower insertions when resizing occurs (requires copying)</li> <li>Internally uses a static array as its storage</li> </ul>"},{"location":"Data%20Science/DSA/arrays.html#memory-structure-aufbau-im-speicher","title":"Memory Structure (Aufbau im Speicher)","text":""},{"location":"Data%20Science/DSA/arrays.html#storing-static-arrays","title":"Storing Static Arrays","text":"<ul> <li>Stored as a contiguous block of memory</li> <li>Each element\u2019s address can be calculated as:</li> </ul> <pre><code>Address(i) = adress_of_first + i * size_of_element\n</code></pre>"},{"location":"Data%20Science/DSA/arrays.html#visualization-ascii","title":"Visualization (ASCII)","text":"<pre><code>Static Array (contiguous memory):\n[10][20][30][40][50]\n \u2191   \u2191   \u2191   \u2191   \u2191\n |   |   |   |   |\n +---+---+---+---+--&gt; continuous memory block\n\nDynamic Array (ArrayList internal):\nArrayList \u2192 [ref] \u2192 [10][20][30][--empty--]\nWhen full \u2192 new larger array \u2192 [10][20][30][40][50][--empty--][--empty--]\n</code></pre>"},{"location":"Data%20Science/DSA/arrays.html#complexity","title":"Complexity","text":"Operation Static Array Dynamic Array Access O(1) O(1) Insert at end O(n) Amortized O(1) Insert at index O(n) O(n) Delete O(n) O(n) Resize \u2013 O(n) (copying elements)"},{"location":"Data%20Science/DSA/arrays.html#arrays-vs-linked-lists","title":"Arrays vs Linked Lists","text":"Feature Arrays Linked Lists Memory layout Contiguous Scattered (each node has a pointer) Access time O(1) (index) O(n) (sequential traversal) Insertion/Deletion O(n) O(1) (if node reference known) Memory overhead Low Higher (extra pointer per node) Cache efficiency High Low"},{"location":"Data%20Science/DSA/arrays.html#summary","title":"Summary","text":"<ul> <li>Arrays provide fast access and a simple memory layout.</li> <li>Dynamic arrays offer flexibility but require occasional copying during resizing.</li> <li>Choosing between static arrays, dynamic arrays, and linked lists depends on the need for speed, memory efficiency, or flexibility.</li> </ul>"},{"location":"Data%20Science/DSA/avl_trees.html","title":"AVL Trees","text":"<p>11.12.2025 - AVL Trees are special type of binary tree, they aim for optimal time complexity and solve the worst case problem of a binary tree, that can and up looking nearly like a linked list. AVL solves this problem by garanting a possibly best height balance, with only the deepast level being incomplete. What sounds like an easy solution brings a list of complicated methods for the tree.</p> <p>The height balance is defined: <code>height(node.right) - height(node.left) = -1,0,+1</code> Following: <code>h = 2*log(n)</code> To know what your height is, each node stores it's height.</p>"},{"location":"Data%20Science/DSA/avl_trees.html#changed-methods","title":"Changed Methods","text":"<p>AVL-Trees methods are the same as of a binary tree, only the ones that change something on the structure are slightly changed. They just work normal, just like e.g. BST, but after performing, you have to check wheater the Tree is balanced and update the height of each node. For AVL-Trees the following methods are changed compared to a simple binary tree:</p> <ul> <li>set(): if you get an array and should create a tree with it</li> <li>remove(): remove a node from the tree</li> <li>add(): add a node to the tree</li> </ul> <p>Therefor we encounter a new tool: Rotation </p> <ul> <li>how, what etc.</li> </ul>"},{"location":"Data%20Science/DSA/avl_trees.html#add","title":"add()","text":""},{"location":"Data%20Science/DSA/avl_trees.html#algorithm","title":"Algorithm","text":"<ul> <li>perform normal add method</li> <li>walk up the tree and update the height of each ancestor</li> <li>rebalance if needed</li> </ul>"},{"location":"Data%20Science/DSA/avl_trees.html#implementation","title":"Implementation","text":"<pre><code>def add(node):\n    def add(id, node=root):\n    if node.id = id\n        return False\n    if node.id &lt; id:\n        if node.right == null:\n            nNode = new Node(id, node)\n            node.right = nNode\n            update(nNode)\n            return True\n        return add(id, node.right)\n    if node.left == null:\n        nNode = new Node(id, node)\n        node.left = nNode\n        update(nNode)\n        return True\n    return add(id, node.left)\n</code></pre>"},{"location":"Data%20Science/DSA/avl_trees.html#remove","title":"remove()","text":"<pre><code>def remove(id, node=get(id)):\n    if node == null:\n        return False\n    if node.is_leaf:\n        balance(node)\n        node.remove                                 # goes to the parent and removes the pointer to the node\n        return True\n    if node.left != null:\n        swap(node, predecessor(node))\n        return remove(id, node)\n</code></pre>"},{"location":"Data%20Science/DSA/avl_trees.html#helping-methods","title":"Helping methods","text":""},{"location":"Data%20Science/DSA/avl_trees.html#updating-the-tree-after-structure-changes","title":"Updating the tree after structure changes","text":"<ul> <li>update height</li> <li>check if it's balanced</li> <li>if the bouncefaktor (<code>bf=l.height-r.height</code>) is not -1, 0, 1 it isn't</li> <li>if not: rebalance and update height</li> </ul> <pre><code>def balance(node, node_before=null):\n    if node.bf &gt; 1 or node.bf &lt; -1:             # unbalanced\n        rebalance(node_before)\n    if node.parent == null:                     # is root\n        return\n    node.parent.set_height(node.height+1)       # go to next\n    balance(node.parent, node)\n\ndef rebalance(node):                            # node is the one under/before the one out of balance\n    c_bf =  node.bf()\n    p_bf = node.parent.bf()\n    if c_bf &lt; 0 and p_bf &lt; 0:\n        left_rotate(node)\n        return\n    if c_bf &gt; 0 and p_bf &gt; 0:\n        right_rotate(node)\n        return\n    if c_bf &gt; 0 and p_bf &lt; 0:\n        node = node.left\n        right_rotate(node)\n        left_rotate(node)\n    if c_bf &lt; 0 and p_bf &gt; 0:\n        node = node.left\n        right_rotate(node)\n        left_rotate(node)\n</code></pre>"},{"location":"Data%20Science/DSA/avl_trees.html#balancenoderoot","title":"balance(node=root)","text":"<p>Left rotation:</p> <ul> <li>parent becomes left_child</li> <li>left child becomes right_child of parent</li> </ul> <p>Right rotation:</p> <ul> <li>parent becomes right child</li> <li>right child becomes left_child of parent</li> </ul> <pre><code>def left_rotate(node):\n    l_child = node.left\n    p_parent = node.parent.parent\n    parent = node.parent\n    node.left = parent\n    parent.right = l_child\n    parent.parent = node\n    node.parent = p_parent\n    if l_child != null:\n        l_child.parent = parent\n    if p_parent != null:\n        if p_parent.left == parent:\n            p_parent.left = node\n        else:\n            p_parent.right = node    \n    if parent.left.height &gt; parent.right.height:        # update height parent\n        parent.height = parent.left.height + 1\n    else:\n        parent.height = parent.right.height + 1\n    if node.left.height &gt; node.right.height:        # update height rotated node\n        node.height = node.left.height + 1\n    else:\n        node.height = node.right.height + 1\n\ndef right_rotate(node):\n    r_child = node.right\n    parent = node.parent\n    p_parent parent.parent\n    node.parent = p_parent              # new parent of node\n    if p_parent != null:\n        if p_parent.left == parent:\n            p_parent.left = node\n        else:\n            p_parent.right = node \n    node.right = parent                 # former parent\n    parent.parent = node \n    parent.left = right_child           # former right child\n    if l_child != null:\n        l_child.parent = parent\n    if parent.left.height &gt; parent.right.height:        # update height parent\n        parent.height = parent.left.height + 1\n    else:\n        parent.height = parent.right.height + 1\n    if node.left.height &gt; node.right.height:        # update height rotated node\n        node.height = node.left.height + 1\n    else:\n        node.height = node.right.height + 1\n\n</code></pre>"},{"location":"Data%20Science/DSA/bfs.html","title":"Breadth-First Search (BFS)","text":"<p>25.11.2025 Breadth-first search is an Algorithm for searching in graphs. It iterates over the graph and works similar to DFS.</p>"},{"location":"Data%20Science/DSA/bfs.html#algorithm","title":"Algorithm","text":"<ul> <li>Start value <code>v</code></li> <li>You have a list, where you store, which nodes you visit. <code>marked = [False] * Graph.size()</code></li> <li> <p>You also have a queue, that has the start value stored.</p> </li> <li> <p>v = queue.pop()</p> </li> <li>visit(v)</li> <li>mark(v)</li> <li>iterate through all neighbors and put them in the queue</li> <li>Repeat 1.-4. while there are still vertixes in the queue</li> </ul>"},{"location":"Data%20Science/DSA/bfs.html#complexity","title":"Complexity","text":"<ul> <li>V is the Vertixes and E is Edges</li> <li>Time: O(V+E)</li> <li>Space: O(V)</li> </ul>"},{"location":"Data%20Science/DSA/bfs.html#implementation","title":"Implementation","text":"<pre><code>def bfs(G, v):\n    marked = [False] * G.size\n    queue = [v]\n    while len(queue) &gt; 0:\n        v = queue.pop(0)\n        if not marked[v]:\n            visit(v)\n            marked[v] = True\n            for w in G.neighbors(v)\n                if not marked[w]\n                    queue.append(w)\n</code></pre>"},{"location":"Data%20Science/DSA/big_o_notation.html","title":"Big O Notation","text":"<p>28.10.2025 Big O notation is used to describe the performance or complexity of an algorithm. It provides the worst case time or space requirements in terms of the input size. You can devide Big O in Time Complexity and Space Complexity.</p>"},{"location":"Data%20Science/DSA/big_o_notation.html#common-big-o-notations","title":"Common Big O Notations","text":"Big O Notation Description Explanation O(1) Constant Time The algorithm's performance is constant and does not change with the size of the input data set. O(n) Linear Time The algorithm's performance grows linearly with the size of the input data set. O(n^2) Quadratic Time The algorithm's performance is proportional to the square of the size of the input data set. (e.g., nested loops). Cubic Time etc. is possible as well. O(log n) Logarithmic Time The algorithm's performance doubles with each addition to the input data set. O(2^n) Exponential Time The algorithm's performance grows logarithmically in relation to the input size."},{"location":"Data%20Science/DSA/big_o_notation.html#time-vs-space-complexity","title":"Time vs. Space Complexity","text":"<ul> <li>Time Complexity refers to the amount of time an algorithm takes to complete as a function of the input size. It is often expressed using Big O notation to describe how much time is required in the worst case. In simple terms you can say, you count the number of operations or steps that grow with input size n.</li> <li>Space Complexity refers to the amount of memory an algorithm uses as a function of the input size. Like time complexity, it is also expressed using Big O notation to describe how much memory is required in the worst case. Simplified you count the extra memory (variables, arrays, recursion stack, etc.) that grows with input size n.</li> </ul>"},{"location":"Data%20Science/DSA/big_o_notation.html#calculating-big-o-notation","title":"Calculating Big O Notation","text":"<p>When calculating Big O notation, focus on the part of the algorithm that grows the fastest as the input size increases. Some general rules to follow:</p> <ol> <li>Ignore Constants: O(2n) and O(3n) are simplified to O(n).</li> <li>Drop Non-Dominant Terms: In O(n^2 + n), the n^2 term dominates as n grows large, so it simplifies to O(n^2).</li> <li>Nested Loops: Multiply the complexities of nested loops. For example, a loop inside another loop each running n times results in O(n^2).</li> <li>Sequential Operations: Add the complexities of sequential operations. For example, O(n) + O(n) simplifies to O(n).</li> </ol>"},{"location":"Data%20Science/DSA/big_o_notation.html#examples","title":"Examples","text":""},{"location":"Data%20Science/DSA/big_o_notation.html#example-1-constant-time-o1","title":"Example 1: Constant Time - O(1)","text":"<pre><code>def say_hello(arr):\n    print(\"Hello, World!\")\n</code></pre> <p>This function runs in constant time O(1) because it always takes the same amount of time to execute, regardless of the size of the input array.</p>"},{"location":"Data%20Science/DSA/big_o_notation.html#example-2-linear-time-on","title":"Example 2: Linear Time - O(n)","text":"<pre><code>def print_elements(arr):\n    for element in arr:\n        print(element)\n</code></pre> <p>This function runs in linear time O(n) because the time it takes to execute grows linearly with the size of the input array.</p>"},{"location":"Data%20Science/DSA/big_o_notation.html#example-3-quadratic-time-on2","title":"Example 3: Quadratic Time - O(n^2)","text":"<pre><code>def print_pairs(arr):\n    for i in arr:\n        for j in arr:\n            print(i, j)\n</code></pre> <p>This function runs in quadratic time O(n^2) because it contains a nested loop, resulting in the time taken growing proportionally to the square of the size of the input array.</p>"},{"location":"Data%20Science/DSA/big_o_notation.html#example-4-logarithmic-time-olog-n","title":"Example 4: Logarithmic Time - O(log n)","text":"<pre><code>def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n</code></pre> <p>This function runs in logarithmic time O(log n) because with each iteration, it halves the size of the input array it needs to search through.</p>"},{"location":"Data%20Science/DSA/big_o_notation.html#example-5-exponential-time-o2n","title":"Example 5: Exponential Time - O(2^n)","text":"<pre><code>def fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n</code></pre> <p>This function runs in exponential time O(2^n) because the number of function calls doubles with each increase in the input size n. Fibonacci is called twice for each execution.</p>"},{"location":"Data%20Science/DSA/binary_search.html","title":"Binary Search","text":"<p>01.11.2025 A search algoritm, similar to binary tree</p> <ul> <li>The idea of Binary Search is to repeatedly divide the search interval in half  </li> <li>It only works on sorted arrays </li> <li>Much faster than Linear Search for large datasets  </li> </ul>"},{"location":"Data%20Science/DSA/binary_search.html#algorithm","title":"Algorithm","text":"<ol> <li>Set <code>low = 0</code> and <code>high = len(arr) - 1</code> </li> <li>While <code>low &lt;= high</code>:  </li> <li>Compute <code>mid = (low + high) // 2</code> </li> <li>If <code>arr[mid] == target</code>: return <code>mid</code> </li> <li>If <code>arr[mid] &lt; target</code>: search the right half \u2192 <code>low = mid + 1</code> </li> <li>If <code>arr[mid] &gt; target</code>: search the left half \u2192 <code>high = mid - 1</code> </li> <li>If the loop ends without finding the target \u2192 return -1 </li> </ol>"},{"location":"Data%20Science/DSA/binary_search.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:</li> <li>Best case: O(1) \u2014 target found at the first mid check  </li> <li>Worst case: O(log n) \u2014 halving search space each step  </li> <li>Average case: O(log n)</li> <li>Space Complexity:</li> <li>Iterative version: O(1)  </li> <li>Recursive version: O(log n) \u2014 due to recursion stack  </li> </ul>"},{"location":"Data%20Science/DSA/binary_search.html#code-example-iterative","title":"Code Example (Iterative)","text":"<pre><code>def binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid                   # found the target\n        elif arr[mid] &lt; target:\n            low = mid + 1                # search right half\n        else:\n            high = mid - 1               # search left half\n    return -1                            # not found\n</code></pre>"},{"location":"Data%20Science/DSA/binary_search.html#code-example-recursive","title":"Code Example (Recursive)","text":"<pre><code>def binary_search_recursive(arr, target, low, high):\n    if low &gt; high:\n        return -1                        # base case: not found\n\n    mid = (low + high) // 2\n    if arr[mid] == target:\n        return mid                       # found the target\n    elif arr[mid] &lt; target:\n        return binary_search_recursive(arr, target, mid + 1, high)  # search right half\n    else:\n        return binary_search_recursive(arr, target, low, mid - 1)   # search left half\n</code></pre>"},{"location":"Data%20Science/DSA/binary_trees.html","title":"Binary Trees","text":"<p>10.12.2025 - Binary trees are a fundamental data structure in computer science, widely used for various applications such as searching, sorting, and hierarchical data representation. A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. A node without children is called a leaf node. How many parents/ancestors a node has, declares its depth or level in the tree. The topmost node is called the root node. The depth of the root node is 0, its level is 0 aswell. The heightof a node is defined as the number of edges on the longest path from the node to a leaf node. The height of a tree is the height of its root node. Edges are the connections between nodes. A subtree is a portion of a tree that consists of a node and all its descendants. </p>"},{"location":"Data%20Science/DSA/binary_trees.html#types-of-binary-trees","title":"Types of Binary Trees","text":"<p>A binary tree has allways a maximum of two children per node, but there are different types of binary trees based on their structure and properties:</p> <ul> <li>Binary Search Tree (BST): A binary tree where the left subtree of a node contains only nodes with values less than the node's value, and the right subtree contains only nodes with values greater than the node's value. This property makes BSTs efficient for searching, insertion, and deletion operations. It's kind of like binary search.</li> <li>AVL Tree: A self-balancing binary search tree where the difference in heights between the left and right subtrees of any node (the balance factor) is at most 1. This ensures that the tree remains approximately balanced, leading to O(log n) time complexity for search, insertion, and deletion operations.</li> <li>There are list of more types of binary trees, but they would blow up the scope of this document.</li> </ul>"},{"location":"Data%20Science/DSA/binary_trees.html#traversal-order","title":"Traversal order","text":"<p>Traversal order is what defines the order in which nodes are visited in a binary tree. There are different ways to traverse, but the most common ones is from left to right. you visit the left subtree, then the root node, and finally the right subtree. This is called in-order traversal and it results in visiting the nodes in ascending order for binary search trees. It is important to say that traversal order is only an implicit property of binary trees, not a structural one. </p>"},{"location":"Data%20Science/DSA/binary_trees.html#implementation-of-binary-trees","title":"Implementation of Binary Trees","text":""},{"location":"Data%20Science/DSA/binary_trees.html#trav-order-operations","title":"Trav. order operations","text":"<p>Iterating implemented recursiv:</p> <pre><code>def iter(node):\n    if node == null:\n        return\n    iter(node.left)\n    output(node)\n    iter(node.right)\n</code></pre> <p>Getting the first node of a subtree:</p> <pre><code>def subtree_first(node):\n    if node.has_left:\n        return node\n    return subtree_first(node.left)\n</code></pre> <p>Getting the successor (the one after the node in trav. order):</p> <pre><code>def successor(node):\n    if node.right != null:\n        while(True):\n            if node = node.parent.left:                # walk up until you go right\n                return parent\n            node = node.parent                     \n    return subtree_first(node.right)\n</code></pre> <p>Getting the predecessors (the one before the node in trav. order):</p> <pre><code>def predecessor(node):\n    if node.left != null:\n        while(True):\n            if node = node.parent.right:                # walk up until you go left\n                return parent\n            node = node.parent\n    return subtree_last(node.left)\n</code></pre>"},{"location":"Data%20Science/DSA/binary_trees.html#bst-standard-operations","title":"BST standard-operations","text":"<pre><code>def get(id, node=root):\n    if node == null:\n        return null\n    if node.id == id:\n        return node\n    if node.id &lt; id:\n        return get(id,node.right)\n    return get(id,node.left)\n\ndef add(id, node=root):\n    if node.id = id\n        return False\n    if node.id &lt; id:\n        if node.right == null:\n            node.right=new Node(id, node)\n            return True\n        return add(id, node.right)\n    if node.left == null:\n        node.left=new Node(id, node)\n        return True\n    return add(id, node.left)\n\ndef remove(id, node=get(id)):\n    if node == null:\n        return False\n    if node.is_leaf:\n        node.remove                                 # goes to the parent and removes the pointer to the node\n        return True\n    if node.left != null:\n        swap(node, predecessor(node))\n        return remove(id, node)\n\ndef contains(id):\n    if get(id) == null:\n        return False\n    return True\n\ndef toString(node=root):\n    if node == null:\n        return \"\"\n    return toString(node.left) + node.toString() + toString(node.right)\n</code></pre>"},{"location":"Data%20Science/DSA/bubble_sort.html","title":"Bubble sort","text":"<p>30.10.2025  Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm gets its name because smaller elements \"bubble\" to the top of the list.</p>"},{"location":"Data%20Science/DSA/bubble_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Start at the beginning of the array.</li> <li>Compare the first two adjacent elements. If the first element is greater than the second, swap them.</li> <li>Move to the next pair of adjacent elements and repeat step 2.</li> <li>Continue this process until the end of the array is reached. This completes one pass.</li> <li>Repeat steps 1-4 for a total of n-1 passes, where n is the number of elements in the array. After each pass, the largest unsorted element will have \"bubbled\" to its correct position at the end of the array.</li> </ol>"},{"location":"Data%20Science/DSA/bubble_sort.html#time-complexity","title":"Time Complexity","text":"<ul> <li>Best Case: O(n) - This occurs when the array is already sorted. An optimized version of bubble sort can detect this and stop early.</li> <li>Average &amp; Worst Case: O(n^2) - This occurs for random orderings of the array.</li> </ul>"},{"location":"Data%20Science/DSA/bubble_sort.html#space-complexity","title":"Space Complexity","text":"<ul> <li>O(1) - Bubble sort is an in-place sorting algorithm, meaning it requires a constant amount of additional memory space.</li> </ul>"},{"location":"Data%20Science/DSA/bubble_sort.html#example-implementation-in-python","title":"Example Implementation in Python","text":"<pre><code>def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n-1):\n        swapped = False                                     # Track if a swap was made\n        for j in range(0, n-i-1):\n            if arr[j] &gt; arr[j+1]:                           # Compare adjacent elements\n                arr[j], arr[j+1] = arr[j+1], arr[j]         # Swap if they are in the wrong order\n                swapped = True\n        if not swapped:                                     # If no swaps were made, the array is sorted \n            break\n    return arr\n</code></pre>"},{"location":"Data%20Science/DSA/bucket_sort.html","title":"Bucket Sort","text":"<p>01.11.2025 Bucket Sort is a sorting algorithm that sorts out-of-place. It puts the elements in buckets. (Each bucket is for a range of values) and than sort the buckets (with another sorting algorithm), before setting it back together.</p>"},{"location":"Data%20Science/DSA/bucket_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Put in buckets. (e.g.: for an array with numbwers between 0-1 you would have 10 buckets with a range of 0.1 each)</li> <li>Sort each bucket</li> <li>Set the array back together</li> </ol>"},{"location":"Data%20Science/DSA/bucket_sort.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity: Depends on the Sorting Algoritm used</li> <li>Space Complexity: 0(n+k) - Bucket sort requires additional space for the buckets. The total memory used depends on the number of elements (n) and the number of buckets (k)</li> </ul>"},{"location":"Data%20Science/DSA/bucket_sort.html#code-example","title":"Code Example","text":"<pre><code>def bucket_sort(arr):           # for array with values 0-1\n    buckets = [[] for _ in range(10)]\n    for v in arr:\n        buckets[int(v * 10)].append(v)\n    for b in buckets:\n        insertion_sort(b)\n    pointer=0\n    for b in buckets:\n        for v in b:\n            arr[pointer]=v\n            pointer+=1\n    return arr\n</code></pre>"},{"location":"Data%20Science/DSA/counting_sort.html","title":"Counting Sort","text":"<p>30.10.2025 Counting Sort is a non-comparison-based sorting algorithm. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted.</p> <ul> <li>The basic idea behind Counting Sort is to count the frequency of each distinct element in the input array and use that information to place the elements in their correct sorted positions.</li> <li>It works well when the range of input elements is small and comparable to the size of the array. For example, for input [1, 4, 0, 2, 1, 1], the size of array is 6 and range of elements is from 0 to 4</li> <li>If range of input array is of order more than n Log n where n is size of the array, then we can better sort the array using a standard comparison based sorting algorithm like Merge Sort.</li> </ul>"},{"location":"Data%20Science/DSA/counting_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>get the max_value and the amount of each value</li> <li>set the numbers in the array with the value to prefix sum (howmuch is the amount of elements before the number and the sum of the element itself). It is used to give the index where the last of the numbers is placed (Index: cntArr[i] - 1)</li> <li>go backwards through the original array and check in the cntArr where each element should be placed</li> </ol>"},{"location":"Data%20Science/DSA/counting_sort.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity: O(n+k)</li> <li>Space Complexity: O(n+k)</li> </ul>"},{"location":"Data%20Science/DSA/counting_sort.html#code-example","title":"Code Example","text":"<pre><code>def quick_sort(arr):\n    max =  max(arr)                     # Save the max value\n    cntArr = [None] * (max + 1)         # Create an array with a field for each value up to max value, \n                                        # so the index is equal to the value it represents\n    for v in arr:                       # The field with the index is incremented by 1\n        cntArr[v] += 1\n\n    for i in range(1, max):             # Calculate where the last index is for the number, (it is the index + 1)\n        cntArr[i] += cntArr[i-1]\n\n    ans = [0] * len(arr)\n    for i in range(n-1, -1, -1)         # iterating backwards over the given arr\n        v = arr[i]                      # the number we're placing\n        ans[cntArr[v - 1]] = v          # place it at the index that is saved in the cntArr\n        cntArr[v] -= 1                  # reset the index in the cntArr\n\n    return arr\n</code></pre>"},{"location":"Data%20Science/DSA/dfs.html","title":"Depth-First Search","text":"<p>25.11.2025 Depth-First Search is an Algorithm for searching in graphs. It iterates over the graph and works similar to BFS.</p>"},{"location":"Data%20Science/DSA/dfs.html#algorithm","title":"Algorithm","text":"<ul> <li>It can be implemented either recursive or with a stack similar as BFS.</li> <li>Recursive:</li> <li>Start value <code>v</code></li> <li> <p>You have a list, where you store, which nodes you visit. <code>marked = [False] * Graph.size()</code></p> </li> <li> <p>visit(v)</p> </li> <li>mark(v)</li> <li>iterate through all neighbors:</li> <li>call recursion on each of them</li> <li>Stack:</li> <li> <p>Additionaly to the start value and the marked-list, we have a stack. It has stored the start value <code>v</code>.</p> </li> <li> <p>v = stack.pop</p> </li> <li>visit(v)</li> <li>mark(v)</li> <li>Iterate through all neighbors and put them on the stack</li> <li>Repeat 1.-4. while there are still vertixes in the stack</li> <li>There is also the option to do it <code>post order</code>. That means to make the visit call at the end, when you declared the vertix as a dead end. The other way (that I covered) is called <code>pre order</code>.</li> </ul>"},{"location":"Data%20Science/DSA/dfs.html#complexity","title":"Complexity","text":"<ul> <li>V is the Vertices and E is Edges</li> <li>Time: O(V+E)</li> <li>Space: O(V)</li> </ul>"},{"location":"Data%20Science/DSA/dfs.html#implementation-recursive","title":"Implementation Recursive","text":"<pre><code>marked = [False] * G.size\ndef dfs(G,v):\n    visit(v)\n    marked[v] = True\n    for w in G.neighbors(v):\n        if not marked[w]:\n            dfs(G, w)\n</code></pre>"},{"location":"Data%20Science/DSA/dfs.html#implementation-with-stack","title":"Implementation with Stack","text":"<pre><code>def bfs(G, v):\n    marked = [False] * G.size\n    stack = [v]\n    while len(queue) &gt; 0:\n        v = stack.pop(len(stack)-1)       # pop last\n        if not marked[v]:\n            visit(v)\n            marked[v] = True\n            for w in G.neighbors(v)\n                if not marked[w]\n                    stack.append(w)\n</code></pre>"},{"location":"Data%20Science/DSA/dictionaries.html","title":"Dictionaries","text":"<p>04.11.2025 A Dictionary (also called a map or associative array) is a data structure that stores key\u2013value pairs. Each key in a dictionary is unique, and it is used to quickly access its associated value. Internally, most dictionaries (like in Python or Java\u2019s <code>HashMap</code>) are implemented using a hash table, which provides average-case constant time complexity O(1) for lookups, insertions, and deletions. If two keys produce the same hash value, a collision occurs, and it must be resolved using one of several collision handling techniques.</p>"},{"location":"Data%20Science/DSA/dictionaries.html#how-dictionaries-work","title":"How Dictionaries Work","text":"<ol> <li>A hash function is applied to the key \u2192 produces a hash value (integer).  </li> <li>The hash value is mapped to an index in an internal array (called a bucket or slot).  </li> <li>The key\u2013value pair is stored in that slot.  </li> <li>When retrieving a value, the key is hashed again and searched in the corresponding slot.  </li> </ol> <p>If the slot is already occupied by another element (a collision), a resolution method is used (e.g., chaining or open addressing).</p>"},{"location":"Data%20Science/DSA/dictionaries.html#example-python-dictionary","title":"Example (Python Dictionary)","text":"<pre><code># Creating a dictionary\nstudent = {\n    \"name\": \"Alice\",\n    \"age\": 22,\n    \"major\": \"Computer Science\"\n}\n\n# Accessing a value by key\nprint(student[\"name\"])       # Output: Alice\n\n# Adding a new key\u2013value pair\nstudent[\"grade\"] = \"A\"\n\n# Deleting an entry\ndel student[\"age\"]\n\n# Iterating through all keys and values\nfor key, value in student.items():\n    print(key, \"-&gt;\", value)\n</code></pre>"},{"location":"Data%20Science/DSA/exponential_search.html","title":"Exponential Search","text":"<p>08.11.2025 Searching Algorithm for sorted lists. Works similar to jump search but the steps increase exponential</p>"},{"location":"Data%20Science/DSA/exponential_search.html#algorithm","title":"Algorithm","text":"<ol> <li>Iterate in steps (<code>i=i*2</code>)</li> <li>If the value is bigger than the searched, you found your interval (<code>I=]i/2;i[</code>)</li> <li>Perform binary search on that interval</li> </ol>"},{"location":"Data%20Science/DSA/exponential_search.html#complexity","title":"Complexity","text":"<ul> <li>Space: O(1) - It's inplace</li> <li>Time: O(log n)</li> </ul>"},{"location":"Data%20Science/DSA/exponential_search.html#code-example","title":"Code Example","text":"<pre><code>def exponential_search(v, arr):\n    i = 1\n    while arr[i] &lt; v:\n        i = i*2\n    if arr[i] == v:\n        return i\n    else:\n        return i/2 + binary_search(v, arr[i/2:i])\n</code></pre>"},{"location":"Data%20Science/DSA/graphs.html","title":"Graphs","text":"<p>29.10.2025 Hypothesis: A graph is only for storing the relation between things. its vertices are only for representing the things and arent the object itself. It is a separate thing. </p>"},{"location":"Data%20Science/DSA/graphs.html#definition","title":"Definition","text":"<p>A graph is a non-linear data structure that consists of a set of vertices (or nodes) and a set of edges that connect pairs of vertices. Graphs are used to represent relationships between objects and can model various real-world systems, such as social networks, transportation networks, and communication networks. Graphs can be classified into:</p> <ul> <li>Directed Graphs (Digraphs): where edges have a direction, indicating a one-way relationship between vertices.</li> <li>Like following someone on Twitter. If A follows B, it does not imply that B follows A.</li> <li>Undirected Graphs: where edges do not have a direction, indicating a two-way relationship between vertices.</li> <li>Like being friends on facebook.</li> </ul>"},{"location":"Data%20Science/DSA/graphs.html#weighted-vs-unweighted-graphs","title":"Weighted vs Unweighted Graphs","text":"<ul> <li>Weighted Graphs: where edges have weights or costs associated with them, representing the strength/cost/time etc. of the relationship.</li> <li>For example, in a transportation network, the weight could represent the distance or travel time between two locations. </li> <li>Unweighted Graphs: where edges do not have any weights; all edges are considered equal.</li> </ul>"},{"location":"Data%20Science/DSA/graphs.html#how-to-store-the-relationsadjacency","title":"How to Store the Relations/Adjacency","text":"<p>There are two common ways to represent graphs in computer memory: Adjacency Matrix and Adjacency List:</p>"},{"location":"Data%20Science/DSA/graphs.html#adjacency-matrix","title":"Adjacency Matrix","text":"<ul> <li>A 2D array of size V x V where V is the number of vertices in the graph.</li> <li>Every Vertex has a row and a column.</li> <li>If there is an edge from vertex i to vertex j, then the cell at row i and column j is marked with a 1 (or the weight of the edge in weighted graphs); otherwise, it is marked with a 0.</li> <li>Space Complexity: O(V^2), which can be inefficient for sparse graphs.</li> </ul> <pre><code># Example of an adjacency matrix for a directed graph\nadjacency_matrix = [\n   # A  B  C  D\n    [0, 1, 0, 0],   # A\n    [0, 0, 1, 1],   # B\n    [0, 0, 0, 1],   # C\n    [0, 0, 0, 0]    # D\n]\n</code></pre> <ul> <li>In this example:</li> <li>A has an edge to B</li> <li>B has edges to C and D</li> <li>C has an edge to D</li> <li>D has no edges</li> </ul>"},{"location":"Data%20Science/DSA/graphs.html#adjacency-list","title":"Adjacency List","text":"<ul> <li>Each vertex has a linked list or a dynamic array that contains a list of all the vertices it is connected to by an edge.</li> <li>More space-efficient for sparse graphs.</li> <li>Space Complexity: O(V + E), where E is the number of edges in the graph. </li> </ul>"},{"location":"Data%20Science/DSA/graphs.html#traversal-algorithms","title":"Traversal Algorithms","text":"<p>Graph traversal algorithms are used to visit all the vertices and edges in a graph. The two most common traversal algorithms are Depth-First Search (DFS) and Breadth-First Search (BFS).</p> <p>Depth-First Search (DFS) Breadth-First Search (BFS)</p>"},{"location":"Data%20Science/DSA/graphs.html#finding-shortest-path","title":"Finding shortest path","text":"<ul> <li>Dijkstra</li> <li>Bellman-Ford</li> </ul> <p>If you want a path that visits all vertices, it's called Hamiltonian path (or circle if it has the same start and end). Finding the shortest hamiltionian path/circle is a NP-Hard/NP-Complete problem. The problem for the shortes circle is called Travelling Salesman Problem (TSP).</p>"},{"location":"Data%20Science/DSA/hash_tables.html","title":"Hash Tables","text":"<p>04.11.2025 A Hash Table is a data structure that implements an associative array, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. This allows for average-case constant time complexity O(1) for lookups, insertions, and deletions. However, in the worst case (e.g., many collisions), these operations can degrade to O(n). Hash tables are widely used in various applications, including databases and caching mechanisms. Hash-Functions decide in which slot the element belongs. If there is already an element, you have a collision, that has to be handled.</p>"},{"location":"Data%20Science/DSA/hash_tables.html#example-hash-functions","title":"Example hash functions","text":"<ul> <li>using the position in the alphabet, if it is out of range, you can use mod:</li> </ul> <pre><code>-&gt; sarah -&gt; s - a = 18 -&gt; out of range for size 8\n-&gt; 18 mod 8 = 2\n-&gt; index 7\n</code></pre> <ul> <li>commen hash-functions:</li> <li>djb2 hash: </li> </ul>"},{"location":"Data%20Science/DSA/hash_tables.html#collision-handling","title":"Collision handling","text":""},{"location":"Data%20Science/DSA/hash_tables.html#chaining","title":"Chaining","text":"<p>Putting a linked list at every \"spot\", inserting at the head</p>"},{"location":"Data%20Science/DSA/hash_tables.html#linear-probingopen-addressing","title":"Linear probing/Open addressing","text":"<p>Put the element to the next free/empty \"spot\"</p>"},{"location":"Data%20Science/DSA/hash_tables.html#double-hashing","title":"Double hashing","text":"<p>Similar to Linear probing, but you skip a declared number instead than allways 1</p> <pre><code>i = h(key) mod 8\n(i + c) mod 8\n(i + 2c) mod 8\n</code></pre> <p>-&gt; choose a number whose greatest commom divisor with the size of the arr is 1</p>"},{"location":"Data%20Science/DSA/heap_sort.html","title":"Heap Sort","text":"<p>30.12.2025  Heap sort is an efficient comparison-based sorting algorithm that uses a binary heap data structure. It works by first organizing the array into a heap (usually a max-heap), where the largest element is always at the root. The largest element is then repeatedly removed from the heap and placed at the end of the array, resulting in a sorted list.</p>"},{"location":"Data%20Science/DSA/heap_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Build a max-heap from the input array.</li> <li>The largest element is now at the root of the heap.</li> <li>Swap the root element with the last element of the heap.</li> <li>Reduce the size of the heap by one (excluding the last, now sorted, element).</li> <li>Heapify the root element to restore the max-heap property.</li> <li>Repeat steps 2\u20135 until the heap size is reduced to one.</li> </ol>"},{"location":"Data%20Science/DSA/heap_sort.html#time-complexity","title":"Time Complexity","text":"<ul> <li>Best Case: O(n log n) \u2013 Building the heap takes O(n) time and each extraction takes O(log n).</li> <li>Average Case: O(n log n)</li> <li>Worst Case: O(n log n)</li> </ul>"},{"location":"Data%20Science/DSA/heap_sort.html#space-complexity","title":"Space Complexity","text":"<ul> <li>O(1) \u2013 Heap sort is an in-place sorting algorithm and does not require additional memory beyond a constant amount.</li> </ul>"},{"location":"Data%20Science/DSA/heap_sort.html#example-implementation-in-python","title":"Example Implementation in Python","text":"<pre><code>def heap_sort(arr):\n    n = len(arr)\n\n    # Build a max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]   # Swap\n        heapify(arr, i, 0)\n\n    return arr\n\n\ndef heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # Check if left child exists and is greater than root\n    if left &lt; n and arr[left] &gt; arr[largest]:\n        largest = left\n\n    # Check if right child exists and is greater than largest so far\n    if right &lt; n and arr[right] &gt; arr[largest]:\n        largest = right\n\n    # Change root if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n</code></pre>"},{"location":"Data%20Science/DSA/heaps.html","title":"Heaps","text":"<p>10.12.2025 - Heaps are an implicit data structure, they are just saved as an array, with the order, being the traversal order. It satisfies the Heap-Proptertie. That means that it eather is in descending order, with the parent having allways a bigger or same key (max_heap) or in ascending order, with the parent having a smaller or same key. It also ensures that there are <code>2^i^ nodes at deapth i</code>, except at max deapth were nodes are left justified. Eventhough it is based on the idea of a binary tree, it has a different traversal order: For traversal order, you read every line from top to bottom, from left to right.</p> <pre><code>     1\n    / \\\n   2   3\n  /\\  / \\\n 4  5 6  7\n\n[1,2,3,4,5,6,7]\n</code></pre>"},{"location":"Data%20Science/DSA/heaps.html#why-a-heap","title":"Why a heap","text":"<p>Heaps are used for priority queue sort, thats ideal for allways getting the max or min value.</p>"},{"location":"Data%20Science/DSA/heaps.html#how-does-it-work-implementation","title":"How does it work // implementation","text":""},{"location":"Data%20Science/DSA/heaps.html#_1","title":"Heaps","text":""},{"location":"Data%20Science/DSA/heaps.html#how-does-it-work-implementation_1","title":"How does it work // Implementation","text":""},{"location":"Data%20Science/DSA/heaps.html#heap-types","title":"Heap Types","text":"<p>There are two main types of heaps:</p> <ul> <li>Max-Heap: Each parent node has a key greater than or equal to its children. The maximum value is always stored at the root.</li> <li>Min-Heap: Each parent node has a key smaller than or equal to its children. The minimum value is always stored at the root.</li> </ul> <p>Heap sort uses a max-heap, which is why the following examples focus on it.</p>"},{"location":"Data%20Science/DSA/heaps.html#array-representation","title":"Array Representation","text":"<p>A heap is stored as an array because it is a complete binary tree.</p> <p>For an element at index <code>i</code> (0-based indexing):</p> <ul> <li>Parent index: <code>(i - 1) // 2</code></li> <li>Left child index: <code>2 * i + 1</code></li> <li>Right child index: <code>2 * i + 2</code></li> </ul> <pre><code># Index calculations in a heap array\nparent = (i - 1) // 2\nleft_child = 2 * i + 1\nright_child = 2 * i + 2\n</code></pre> <p>This representation allows heap operations to be performed efficiently and is essential for heap sort.</p>"},{"location":"Data%20Science/DSA/heaps.html#insertion-heapify-up","title":"Insertion (Heapify-Up)","text":"<p>When inserting a new element, it is first added at the end of the array. Then it is repeatedly swapped with its parent until the heap property is restored.</p> <pre><code>def heap_insert(heap, value):\n    heap.append(value)\n    i = len(heap) - 1\n\n    # Heapify-up\n    while i &gt; 0:\n        parent = (i - 1) // 2\n        if heap[i] &gt; heap[parent]:           # max-heap\n            heap[i], heap[parent] = heap[parent], heap[i]\n            i = parent\n        else:\n            break\n</code></pre> <p>This operation takes O(log n) time.</p>"},{"location":"Data%20Science/DSA/heaps.html#removal-extract-max-heapify-down","title":"Removal (Extract Max \u2013 Heapify-Down)","text":"<p>Removing an element always removes the root (the maximum value in a max-heap). The last element is moved to the root and pushed down until the heap property is restored.</p> <pre><code>def extract_max(heap):\n    if len(heap) == 0:\n        return None\n\n    max_value = heap[0]\n    heap[0] = heap[-1]\n    heap.pop()\n\n    heapify_down(heap, 0)\n    return max_value\n</code></pre> <pre><code>def heapify_down(heap, i):\n    n = len(heap)\n\n    while True:\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left &lt; n and heap[left] &gt; heap[largest]:\n            largest = left\n\n        if right &lt; n and heap[right] &gt; heap[largest]:\n            largest = right\n\n        if largest != i:\n            heap[i], heap[largest] = heap[largest], heap[i]\n            i = largest\n        else:\n            break\n</code></pre> <p>This operation also runs in O(log n) time.</p>"},{"location":"Data%20Science/DSA/heaps.html#heapify","title":"Heapify","text":"<p>Heapify is the process of restoring the heap property when it is violated. It is used after removal, insertion, and during heap construction.</p> <pre><code>def heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left &lt; n and arr[left] &gt; arr[largest]:\n        largest = left\n\n    if right &lt; n and arr[right] &gt; arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n</code></pre>"},{"location":"Data%20Science/DSA/heaps.html#building-a-heap","title":"Building a Heap","text":"<p>Before heap sort can begin, the array must be transformed into a max-heap.</p> <pre><code>def build_max_heap(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n</code></pre> <p>Building a heap takes O(n) time.</p>"},{"location":"Data%20Science/DSA/heaps.html#relation-to-heap-sort","title":"Relation to Heap Sort","text":"<p>Heap sort is built directly on these heap operations. First, the array is converted into a max-heap. Then the root element is repeatedly swapped with the last element of the heap and removed. After each removal, the heap is restored using heapify. This process continues until the array is sorted.</p>"},{"location":"Data%20Science/DSA/insertion_sort.html","title":"Insertion sort","text":"<p>30.10.2025 </p> <ul> <li>Insertion Sort is a simple and intuitive sorting algorithm that builds a sorted array one element at a time by repeatedly taking the next element from the unsorted portion and inserting it into its correct position in the sorted portion.</li> <li>It is efficient for small datasets and partially sorted arrays but has a high time complexity.</li> </ul>"},{"location":"Data%20Science/DSA/insertion_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Start with the second element of the array (the first element is considered sorted).</li> <li>Compare the current element with the elements in the sorted portion (to its left).</li> <li>Shift all elements in the sorted portion that are greater than the current element to the right.</li> <li>Insert the current element into its correct position in the sorted portion.</li> <li>Move to the next element in the unsorted portion and repeat steps 2-4 until the entire array is sorted.</li> </ol>"},{"location":"Data%20Science/DSA/insertion_sort.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity: O(n^2) in the average and worst cases, O(n) in the best case (when the array is already sorted, so no element has to be swapped).</li> <li>Space Complexity: O(1) (in-place sorting)</li> </ul>"},{"location":"Data%20Science/DSA/insertion_sort.html#code-example","title":"Code Example","text":"<pre><code>def insertion_sort(arr):\n    n = len(arr)\n    for i in range(1, n)\n        if arr[i] &gt;= arr[i-1]:      # if the next element is bigger, than the last sorted element, it can stay\n            continue\n        for j in reversed(range(i - 1)):            # swap the Element forward(towards index = 0),     \n            if arr[j] &gt; arr[j+1]:                   # until the element in front of it is smaller, than the new element\n                arr[j], arr[j+1]=arr[j+1], arr[j]\n    return arr\n</code></pre>"},{"location":"Data%20Science/DSA/jump_search.html","title":"Jump Search","text":"<p>08.11.2025 Searching Algorithm for sorted lists. Allways jumps in fixed steps, to find a smaller interval where the value has to be in</p>"},{"location":"Data%20Science/DSA/jump_search.html#algorithm","title":"Algorithm","text":"<ol> <li>Iterate in steps (<code>i+=\u221an</code>)</li> <li>If the value is bigger than the searched, you found your interval (<code>I=]i-\u221an;i[</code>)</li> <li>Perform linear search on that interval</li> </ol>"},{"location":"Data%20Science/DSA/jump_search.html#complexity","title":"Complexity","text":"<ul> <li>Space: O(1) - It's inplace</li> <li>Time: O(\u221an)</li> </ul>"},{"location":"Data%20Science/DSA/jump_search.html#code-example","title":"Code Example","text":"<pre><code>def jump_search(n, arr):\n    steps = int(math.sqrt(len(arr)))\n    for i in range(steps, len(arr), steps):\n        if arr[i] &gt; n:\n            return steps + linear_search(n, arr[i-steps:i])\n        if arr[i] == n:\n            return i\n</code></pre>"},{"location":"Data%20Science/DSA/linear_search.html","title":"Linear Search","text":"<p>01.11.2025 The idea of Linear Search is to go through each element of the list one by one.</p> <ul> <li>It is the simplest searching algorithm  </li> <li>Works on both sorted and unsorted arrays  </li> </ul>"},{"location":"Data%20Science/DSA/linear_search.html#algorithm","title":"Algorithm","text":"<ol> <li>Start from the first element of the array  </li> <li>Compare the current element with the target value  </li> <li>If they are equal \u2192 return the current index (target found)  </li> <li>If not, move to the next element  </li> <li>Repeat steps 2\u20134 until the end of the array  </li> <li>If the end is reached and no match is found \u2192 return -1 (target not found)  </li> </ol>"},{"location":"Data%20Science/DSA/linear_search.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:</li> <li>Best case: O(1) \u2014 target is the first element  </li> <li>Worst case: O(n) \u2014 target is the last or not in the array  </li> <li>Average case: O(n/2) \u2248 O(n)</li> <li>Space Complexity:</li> <li>O(1) \u2014 only a few extra variables are used  </li> </ul>"},{"location":"Data%20Science/DSA/linear_search.html#code-example","title":"Code Example","text":"<pre><code>def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i        # return index if found\n    return -1               # return -1 if not found\n</code></pre>"},{"location":"Data%20Science/DSA/linked_lists.html","title":"Linked Lists","text":"<p>28.10.2025 Linear Data Structure</p> <ul> <li>Consists of nodes</li> <li>Each node contains data and a reference to the next node</li> <li>Doubly Linked Lists also have a reference to the previous node</li> <li>Each node is located at different memory locations, in contrast to arrays where elements are stored in contiguous memory locations.</li> <li>They are ideal for dynamic memory allocation</li> <li>Efficient for insertions and deletions</li> <li>Slower access time for elements by index compared to arrays</li> <li>You only store references to the first node (head) and sometimes the last node (tail)  </li> </ul>"},{"location":"Data%20Science/DSA/linked_lists.html#operations","title":"Operations","text":""},{"location":"Data%20Science/DSA/linked_lists.html#insertion","title":"Insertion","text":"<ul> <li>At the beginning (head)</li> <li>At the end (tail)</li> <li>At a specific position</li> </ul>"},{"location":"Data%20Science/DSA/linked_lists.html#example-insertion-at-the-beginning","title":"Example: Insertion at the Beginning","text":"<pre><code>  def insert_at_beginning(new_data):\n      new_node = Node(new_data)               # Create the new node\n      new_node.next = head                    # Make next of new node the old head   \n      head = new_node                         # Move the head to point to the new node\n      return head\n</code></pre>"},{"location":"Data%20Science/DSA/linked_lists.html#example-insertion-at-the-end","title":"Example: Insertion at the End","text":"<pre><code>def insert_at_end(new_data):\n    new_node = Node(new_data)               # Create the new node\n    if head is None:                        # If the Linked List is empty\n        head = new_node                     # Make the new node as head\n    last = head\n    while last.next:                        # Traverse to the last node\n        last = last.next\n    last.next = new_node                    # Change the next of last node\n</code></pre>"},{"location":"Data%20Science/DSA/linked_lists.html#example-insertion-at-a-specific-position","title":"Example: Insertion at a Specific Position","text":"<pre><code>def insert_at_position(new_data, position):\n    new_node = Node(new_data)               # Create the new node\n    if position == 0:                       # If inserting at the head\n        insert_at_beginning(new_data)\n        return\n    current = head\n    for i in range(position - 1):           # Traverse to the node before the position\n        if current is None:                 # If position is greater than the number of nodes\n            raise IndexError(\"Position out of bounds\")\n        current = current.next\n    new_node.next = current.next            # The new node's next points to the current node's next\n    current.next = new_node                 # Current node's next points to the new node\n</code></pre>"},{"location":"Data%20Science/DSA/linked_lists.html#deletion","title":"Deletion","text":""},{"location":"Data%20Science/DSA/linked_lists.html#from-the-beginning","title":"From the Beginning","text":"<ul> <li>make the head point to the node after the current head</li> </ul>"},{"location":"Data%20Science/DSA/linked_lists.html#from-the-end","title":"From the End","text":"<ul> <li>traverse to the second last node and set its next to None</li> </ul>"},{"location":"Data%20Science/DSA/linked_lists.html#from-a-specific-position","title":"From a Specific Position","text":"<ul> <li>traverse to the node before the position</li> <li>this node's next points to the node after the position</li> </ul>"},{"location":"Data%20Science/DSA/linked_lists.html#doubly-linked-lists","title":"Doubly Linked Lists","text":"<ul> <li>Each node contains three fields: data, a reference to the next node, and a reference to the previous node</li> <li>Allows traversal in both directions (forward and backward)</li> <li>It could be useful to store the size of the list for quick access to the number of elements</li> <li>This could be used to e.g. decide whether to traverse from head or tail when accessing an element by index</li> <li>Also for quick size retrieval without traversing the entire list</li> <li>However, it uses more memory due to the additional previous pointer in each node</li> </ul>"},{"location":"Data%20Science/DSA/merge_sort.html","title":"Merge Sort","text":"<p>30.10.2025 Merge sort is a recursive algorithm. The name comes from the process of dividing and merging.</p>"},{"location":"Data%20Science/DSA/merge_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Divide the array in two, until it is only a single element left per array. </li> <li>Merge two elements together, by comparing allways the firt items. </li> </ol>"},{"location":"Data%20Science/DSA/merge_sort.html#time-complexity","title":"Time Complexity","text":"<ul> <li>**Time Complexity: 0(n log(n))</li> <li>**Space Complexity: O(n) - It does not sort in place</li> </ul>"},{"location":"Data%20Science/DSA/merge_sort.html#code-example","title":"Code example","text":"<pre><code>def mergesort(arr):\n    n = len(arr)\n    if(len(arr)&lt;=1):\n        return arr\n    arr1 = arr[:n//2]\n    arr2 = arr[n//2:]\n    return merge(mergesort(arr1),mergesort(arr2),arr)\n\ndef merge(arr1, arr2, parent):\n    pointer1 = 0\n    pointer2 = 0\n    for i in range(len(parent)):\n        if(pointer1 == len(arr1)):                       # if the the first array is empty\n            parent[i]=arr2[pointer2]\n            pointer2 += 1\n        elif(pointer2==len(arr2)):                       # if the second array is empty\n            parent[i]=arr1[pointer1]\n            pointer1 += 1\n        elif(arr1[pointer1] &lt;= arr2[pointer2]):          # if the first arrays element is smaller\n            parent[i] = arr1[pointer1]\n            pointer1 += 1\n        elif(arr1[pointer1] &gt; arr2[pointer2]):           # if the second arrays element is smaller\n            parent[i]=arr2[pointer2]\n            pointer2 += 1\n</code></pre>"},{"location":"Data%20Science/DSA/quick_sort.html","title":"Quick sort","text":"<p>30.10.2025 The Idea of Quick sort is to work similar to Merge sort, but be inplace. It is a recursive algorithm</p>"},{"location":"Data%20Science/DSA/quick_sort.html#algorithm","title":"Algorithm","text":"<ol> <li><code>start = 0</code> and <code>end = len(arr)</code></li> <li>set a pivot to <code>end</code></li> <li>set a variable <code>i = start - 1</code> that will store the index of the last element that is smaller than the pivot</li> <li>iterate trough the array and if you find a variable that is <code>&lt; pivot</code>, increment <code>i</code> and swap the values at <code>i</code> with the one your looking at</li> <li>if you reach the <code>pivot</code>, increment <code>i</code> and swap the values at <code>i</code> and <code>pivot</code></li> <li>repeat 2-6 for <code>I = [start; i[ and ]i; end]</code> until the Interval is &lt;= 1</li> </ol>"},{"location":"Data%20Science/DSA/quick_sort.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:</li> <li>Worst case: O(n^2)</li> <li>Best &amp; Average case: O(n log n)</li> <li>Space Complexity:</li> <li>Worst case: O(n) - it might look like O(1) but you need to also consider the recursion stack</li> <li>Best &amp; Average case: O(log n) - dividing is kind of like a binary tree</li> </ul>"},{"location":"Data%20Science/DSA/quick_sort.html#code-example","title":"Code Example","text":"<pre><code>def quick_sort(arr, start, end):\n    if end - start &lt;= 1:                        # if 1 or 0 elements in the interval: no sorting needed\n        return\n    i = start - 1\n    pivot = end                                 # set pivot to end\n    for j in range(start, end +1):              \n        if j == pivot or arr[j] &lt; arr[pivot]:   # if j's element is smaller than the pivot value or it is the last round\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    quick_sort(arr, start, i-1)                 # calling quick_sort() on the interval before the pivot\n    quick_sort(arr, i+1, end)                   # calling quick_sort() on the interval behind the pivot\n</code></pre>"},{"location":"Data%20Science/DSA/radix_sort.html","title":"Radix Sort","text":"<p>30.12.2025  Radix sort is a non-comparison-based sorting algorithm that sorts numbers by processing individual digits. Instead of comparing elements directly, it distributes elements into buckets according to their digits, starting from the least significant digit (LSD) and moving to the most significant digit (MSD). By repeating this process for each digit position, the list becomes sorted.</p>"},{"location":"Data%20Science/DSA/radix_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Determine the maximum number in the array to know the number of digits.</li> <li>Start with the least significant digit (ones place).</li> <li>Place each element into buckets based on the current digit.</li> <li>Collect the elements from the buckets in order.</li> <li>Move to the next digit position (tens, hundreds, etc.).</li> <li>Repeat steps 3\u20135 until all digit positions have been processed.</li> </ol>"},{"location":"Data%20Science/DSA/radix_sort.html#time-complexity","title":"Time Complexity","text":"<ul> <li>Best Case: O(nk) \u2013 Where n is the number of elements and k is the number of digits in the largest number.</li> <li>Average Case: O(nk)</li> <li>Worst Case: O(nk)</li> </ul>"},{"location":"Data%20Science/DSA/radix_sort.html#space-complexity","title":"Space Complexity","text":"<ul> <li>O(n + k) \u2013 Additional space is required for the buckets used during sorting.</li> </ul>"},{"location":"Data%20Science/DSA/radix_sort.html#example-implementation-in-python","title":"Example Implementation in Python","text":"<pre><code>def radix_sort(arr):\n    if len(arr) == 0:\n        return arr\n\n    max_num = max(arr)\n    exp = 1  # Digit position (1, 10, 100, ...)\n\n    while max_num // exp &gt; 0:\n        counting_sort(arr, exp)\n        exp *= 10\n\n    return arr\n\n\ndef counting_sort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n\n    # Store count of occurrences\n    for i in range(n):\n        index = (arr[i] // exp) % 10\n        count[index] += 1\n\n    # Change count[i] so it contains the actual position of this digit\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    # Build the output array\n    i = n - 1\n    while i &gt;= 0:\n        index = (arr[i] // exp) % 10\n        output[count[index] - 1] = arr[i]\n        count[index] -= 1\n        i -= 1\n\n    # Copy output back to arr\n    for i in range(n):\n        arr[i] = output[i]\n</code></pre>"},{"location":"Data%20Science/DSA/recursion.html","title":"Recursion","text":"<p>04.11.2025 Recursion is a programming technique where a function calls itself in order to solve a problem.</p> <ul> <li>A good example for recursion is factorial (n! = n*(n-1)!)</li> <li>In recursive functions there often is a if-condition: The case with the recursive call, is called recursive case. The other case that works one its own is called base case.</li> </ul>"},{"location":"Data%20Science/DSA/recursion.html#code-example-1-factrorial","title":"Code Example 1: Factrorial","text":"<pre><code>def fact(n):\n    if(n&gt;=1):\n        return n * fact(n-1)\n    else:\n        return 1\n</code></pre>"},{"location":"Data%20Science/DSA/recursion.html#code-example-2-fibernacci","title":"Code Example 2: Fibernacci","text":"<ul> <li>The Fibernacci numbers are: 1,1,2,3,5,8,13,... (adding up the two numbers before)</li> <li>This function returns the n-th fibernacci number</li> </ul> <pre><code>def fib(n):\n    if n &gt;= 3:\n        return fib(n-1) + fib(n-2)\n    else:\n        return 1 \n</code></pre>"},{"location":"Data%20Science/DSA/selection_sort.html","title":"Selection sort","text":"<p>30.10.2025 </p> <ul> <li>Selection sort is a simple comparison-based sorting algorithm.</li> <li>It divides the input list into two parts: a sorted and an unsorted region.</li> <li>The algorithm repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted region and swaps it with the first unsorted element, effectively growing the sorted region by one element.</li> </ul>"},{"location":"Data%20Science/DSA/selection_sort.html#algorithm","title":"Algorithm","text":"<ol> <li>Start with the first element of the array as the current position.</li> <li>Assume the current position is the minimum.</li> <li>Iterate through the unsorted portion of the array to find the actual minimum element.</li> <li>After completing the iteration, swap the minimum element found with the element at the current position.</li> <li>Move the current position one step to the right.</li> <li>Repeat steps 2-5 until the entire array is sorted.</li> </ol>"},{"location":"Data%20Science/DSA/selection_sort.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:0(n^2)</li> <li>Space Complexity: O(1) (in-place sorting)</li> </ul>"},{"location":"Data%20Science/DSA/selection_sort.html#code-example","title":"Code Example","text":"<pre><code>def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min = i                                                 # Assume the minimum is the first element\n        for j in range(i+1,n):                                  # Iterate through the unsorted elements  \n            if arr[j] &lt; arr[min_index]:                         # Update min if a smaller element is found\n                min_index = j\n        if min_index != i:                                      # If A smaller element is found, swap the found minimum element with the first unsorted element \n            arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n</code></pre>"},{"location":"Data%20Science/DSA/stacks_and_queues.html","title":"Stacks and Queues","text":"<p>04.11.2025 Stacks and Queues are Data Structures that have pointers to elements and can only access these.</p>"},{"location":"Data%20Science/DSA/stacks_and_queues.html#stacks","title":"Stacks","text":"<p> Stacks are a linear data structure that follows the Last In First Out (LIFO) principle, where the last element added is the first one to be removed. Common operations include push (add an element) and pop (remove the top element). You can picture it like a stack of pancakes, where you can only access the first one. That means that if you want the third element you have to first remove de items above. It keeps a pointer to the last-added element.</p>"},{"location":"Data%20Science/DSA/stacks_and_queues.html#example","title":"Example","text":"<p>The class <code>stacks</code> is initiated with a <code>pointer = -1</code> and an array in a given size</p> <pre><code>def add(element):\n    pointer += 1\n    arr[pointer]=element\n\ndef get():\n    if pointer == -1:\n        return None\n    return arr[pointer]\n\ndef remove():\n    if pointer == -1:\n        return None\n    pointer -= 1\n    return arr[pointer+1]\n</code></pre>"},{"location":"Data%20Science/DSA/stacks_and_queues.html#queues","title":"Queues","text":"<p> Stacks are a linear data structure that follows the First In First Out (FIFO) principle, where the first element added is the first one to be removed. Common operations include enqueue (add an element to the back) and dequeue (remove the front element). You can picture it like a line of people waiting, where the first person in line is the first to be served.</p>"},{"location":"Data%20Science/DSA/stacks_and_queues.html#example-queue","title":"Example Queue","text":"<p>The class <code>queues</code> is initiated with a <code>first = 0</code>, <code>next = 0</code> and an array in a given size</p> <pre><code>def enqueue(element):\n    if next+1 == first:\n        return\n    arr[next]= element\n    next += 1\n    if next &gt;= arr.length:\n        next = next - arr.length\n\ndef dequeue():\n    if next==first:\n        return None\n    first += 1\n    return arr[first - 1]\n</code></pre>"},{"location":"Data%20Science/DSA/stacks_and_queues.html#deques","title":"Deques","text":"<p>(Double-Ended Queues) are a more versatile version of queues that allow adding and removing elements from both ends. This makes them suitable for scenarios where you need to efficiently manage elements at both the front and back of the collection.</p>"},{"location":"Data%20Science/DSA/string_manipulation.html","title":"String Manipulation Algorithms","text":"<p>06.11.2025 Here is only covered for strictly-lowercase strings. If that is a problem for a specific case, be aware!</p>"},{"location":"Data%20Science/DSA/string_manipulation.html#reversing-a-string","title":"Reversing a string","text":""},{"location":"Data%20Science/DSA/string_manipulation.html#using-backward-traversal-on-time-and-on-space","title":"Using backward traversal \u2013 O(n) Time and O(n) Space","text":"<p>The idea is to start at the last character of the string and move backward, appending each character to a new string res. This new string res will contain the characters of the original string in reverse order.</p> <pre><code>def reverse_string(string):\n    res = []\n\n    for i in range(len(string) - 1, -1, -1):\n        res.append(string[i])\n\n    return ''.join(res)\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#using-two-pointers-on-time-and-o1-space","title":"Using Two Pointers - O(n) Time and O(1) Space","text":"<p>The idea is to maintain two pointers: left and right, such that left points to the beginning of the string and right points to the end of the string.</p> <p>While left pointer is less than the right pointer, swap the characters at these two positions. After each swap, increment the left pointer and decrement the right pointer to move towards the center of the string. This will swap all the characters in the first half with their corresponding character in the second half.</p> <pre><code>def reverse_string(s):\n    left = 0\n    right = len(s) - 1\n    s = list(s)\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#using-recursion-on-time-and-on-space","title":"Using Recursion - O(n) Time and O(n) Space","text":"<p>The idea is to use recursion and define a recursive function that takes a string as input and reverses it. Inside the recursive function,</p> <ul> <li>Swap the first and last element.</li> <li>Recursively call the function with the remaining substring.</li> </ul> <pre><code>def reverseStringRec(arr, l, r):\n    if l &gt;= r:\n        return\n    arr[l], arr[r] = arr[r], arr[l]\n    reverseStringRec(arr, l + 1, r - 1)\n\ndef reverseString(s):\n    arr = list(s)  \n    reverseStringRec(arr, 0, len(arr) - 1)\n    return ''.join(arr)  \n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#using-stack-on-time-and-on-space","title":"Using Stack - O(n) Time and O(n) Space","text":"<p>The idea is to use stack for reversing a string. So, when we push all the characters of a string into the stack, the last character becomes the first one to pop.</p> <pre><code>def reverseString(s):\n    stack = []\n    for char in s:\n        stack.append(char)\n    rev = [''] * len(s)\n    for i in range(len(s)):\n        rev[i] = stack.pop()\n    return ''.join(rev)\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#python-built-in-complexity-depends-on-the-used-method","title":"Python built-in - Complexity depends on the used method","text":"<p>You can also convert the string into an arr or something like that and than reverse it</p> <pre><code>def reverseString(s):\n    # Reverse the string using slicing\n    return s[::-1]\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#reverse-words-in-a-string","title":"Reverse Words in a String","text":"<p>Same methods as for reversing the string, but you split the words (\" \") and than reverse on that array.</p>"},{"location":"Data%20Science/DSA/string_manipulation.html#reversing-a-word","title":"Reversing a word","text":"<p>Same methods as for reversing a string</p>"},{"location":"Data%20Science/DSA/string_manipulation.html#rotations","title":"Rotations","text":""},{"location":"Data%20Science/DSA/string_manipulation.html#generate-all-rotations","title":"Generate all Rotations","text":"<pre><code>def get_rotations(s):\n    rotations = []*len(s)\n    for i in range(len(s)):\n        rotations[i] = s[i:] + s[:i]\n    return rotations\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#check-if-strings-are-rotations-of-each-other","title":"Check if strings are Rotations of each other","text":"<pre><code>def is_rotation(s1, s2):\n    if len(s1) != len(s2):\n        return false\n    for i in range(len(s1)):\n        if s1[i] == s2[1]:\n            if s1[i:] + s1[:i] == s2:\n                return True\n    return False\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#permutations-rearangement-of-the-stringnew-order-but-same-chars","title":"Permutations (Rearangement of the String/new order but same chars)","text":"<pre><code>def generate_permutations(set_beg, s):\n    permutations = []\n    if len(s) &lt;= 1:\n        return set_beg + s\n    for i in range(len(s)): \n        permutations += generate_permutations(set_beg+=s[i], s[:i] + s[i+1:])\n    return permutations\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#removing-duplicates","title":"Removing duplicates","text":"<pre><code>def remove_duplicated_chars(s):\n    occured = [False] * 26\n    new_s = \"\"\n    for c in s:\n        i = c - 'a'\n        if occured[i] == False:\n            new_s += c\n            occured[i] = True\n    return new_s\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#anagrams","title":"Anagrams","text":"<p>Other option would be to have a dict that stores how many times the letter occurs.</p> <pre><code>def is_anagram(s1, s2):\n    frequency = [0] * 26\n    for v in s1:\n        frequency[v - 'a'] += 1\n    for v in s2:\n        frequency[v - 'a'] -= 1\n    for i in frequency :\n        if i != 0:\n            return False\n    return True\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#palindroms","title":"Palindroms","text":"<pre><code>def is_palindrom(s):\n    l = 0\n    r = len(s) - 1\n    while l &lt; r:\n        if s[l] != s[r]:\n            return False\n    return True\n</code></pre>"},{"location":"Data%20Science/DSA/string_manipulation.html#most-repeated-character","title":"Most repeated character","text":"<pre><code>def get_most_repeated_char(s):\n    frequency = [0] * 26\n    for c in s:\n        frequency[c - 'a'] += 1\n        max_v  = frequency[0]\n        max_i = 0\n    for i in range(26):\n        if(max_v &gt; frequency[i]):\n            max_v = frequency[i]\n            max_i = i\n    return char('a' + i)\n</code></pre>"},{"location":"Data%20Science/DSA/ternary_search.html","title":"Ternary Search","text":"<p>08.11.2025 The idea of Ternary Search is to divide the search interval into three parts instead of two.</p> <ul> <li>Works on sorted arrays or unimodal functions (functions that increase then decrease: <code>[1, 3, 7, 12, 9, 5, 2]</code>)</li> <li>It can be used to find either:</li> <li>A target value in a sorted array (similar to binary search)</li> <li>A maximum/minimum value in a unimodal function</li> </ul>"},{"location":"Data%20Science/DSA/ternary_search.html#algorithm","title":"Algorithm","text":"<ol> <li>Set <code>low = 0</code> and <code>high = len(arr) - 1</code></li> <li>While <code>low &lt;= high</code>:</li> <li>Compute two midpoints:<ul> <li><code>mid1 = low + (high - low) // 3</code></li> <li><code>mid2 = high - (high - low) // 3</code></li> </ul> </li> <li>If <code>arr[mid1] == target</code>: return <code>mid1</code></li> <li>If <code>arr[mid2] == target</code>: return <code>mid2</code></li> <li>If <code>target &lt; arr[mid1]</code>: search the left third \u2192 <code>high = mid1 - 1</code></li> <li>Else if <code>target &gt; arr[mid2]</code>: search the right third \u2192 <code>low = mid2 + 1</code></li> <li>Else: search the middle third \u2192 <code>low = mid1 + 1</code>, <code>high = mid2 - 1</code></li> <li>If loop ends without finding the target \u2192 return -1</li> </ol>"},{"location":"Data%20Science/DSA/ternary_search.html#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:</li> <li>Best case: O(1) \u2014 found at first comparison</li> <li>Worst case: O(log\u2083 n) \u2014 dividing search space into three parts each step</li> <li>Average case: O(log\u2083 n)</li> <li>Space Complexity:</li> <li>Iterative version: O(1)</li> <li>Recursive version: O(log\u2083 n) \u2014 due to recursion stack</li> </ul>"},{"location":"Data%20Science/DSA/ternary_search.html#code-example-iterative","title":"Code Example (Iterative)","text":"<pre><code>def ternary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n\n    while low &lt;= high:\n        mid1 = low + (high - low) // 3\n        mid2 = high - (high - low) // 3\n\n        if arr[mid1] == target:\n            return mid1\n        if arr[mid2] == target:\n            return mid2\n\n        if target &lt; arr[mid1]:\n            high = mid1 - 1                   # search left third\n        elif target &gt; arr[mid2]:\n            low = mid2 + 1                    # search right third\n        else:\n            low = mid1 + 1                    # search middle third\n            high = mid2 - 1\n    return -1                                 # not found\n</code></pre>"},{"location":"Data%20Science/DSA/ternary_search.html#code-example-recursive","title":"Code Example (Recursive)","text":"<pre><code>def ternary_search_recursive(arr, target, low, high):\n    if low &gt; high:\n        return -1                             # base case: not found\n\n    mid1 = low + (high - low) // 3\n    mid2 = high - (high - low) // 3\n\n    if arr[mid1] == target:\n        return mid1\n    if arr[mid2] == target:\n        return mid2\n\n    if target &lt; arr[mid1]:\n        return ternary_search_recursive(arr, target, low, mid1 - 1)    # left third\n    elif target &gt; arr[mid2]:\n        return ternary_search_recursive(arr, target, mid2 + 1, high)   # right third\n    else:\n        return ternary_search_recursive(arr, target, mid1 + 1, mid2 - 1)  # middle third\n</code></pre>"},{"location":"Data%20Science/DSA/ternary_search.html#ternary-search-on-a-unimodal-function","title":"Ternary Search on a Unimodal Function","text":"<p>Ternary Search can also be used to find the maximum (or minimum) of a unimodal function, i.e. a function that strictly increases and then strictly decreases.</p>"},{"location":"Data%20Science/DSA/ternary_search.html#algorithm-idea","title":"Algorithm Idea","text":"<ol> <li>Set <code>low</code> and <code>high</code> as the boundaries of the search interval</li> <li>While the interval is large enough:</li> <li>Compute two points:<ul> <li><code>mid1 = low + (high - low) / 3</code></li> <li><code>mid2 = high - (high - low) / 3</code></li> </ul> </li> <li>If <code>f(mid1) &lt; f(mid2)</code> \u2192 the maximum lies in the right segment \u2192 <code>low = mid1</code></li> <li>Else \u2192 the maximum lies in the left segment \u2192 <code>high = mid2</code></li> <li>When <code>high - low</code> becomes very small, the maximum is approximately at <code>low</code> (or <code>high</code>)</li> </ol>"},{"location":"Data%20Science/DSA/ternary_search.html#code-example-finding-maximum","title":"Code Example (Finding Maximum)","text":"<pre><code>def ternary_search_unimodal(f, low, high, eps=1e-6):\n    \"\"\"\n    Finds the maximum point of a unimodal function f(x)\n    within the interval [low, high] using ternary search.\n    \"\"\"\n    while high - low &gt; eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n\n        if f(mid1) &lt; f(mid2):\n            low = mid1        # maximum lies to the right\n        else:\n            high = mid2       # maximum lies to the left\n\n    return (low + high) / 2   # approximate maximum position\n\n# Example usage\ndef f(x):\n    return -(x - 3)**2 + 9     # parabola with max at x = 3\n\nmax_x = ternary_search_unimodal(f, 0, 6)\nprint(\"Maximum at x \u2248\", max_x, \"with value f(x) =\", f(max_x))\n</code></pre>"},{"location":"Data%20Science/DSA/ternary_search.html#output-approximately","title":"Output (approximately)","text":"<pre><code>Maximum at x \u2248 3.0000001 with value f(x) = 9.0\n</code></pre>"},{"location":"Data%20Science/DSA/ternary_search.html#notes","title":"Notes","text":"<ul> <li>Works for continuous, unimodal functions</li> <li>If you\u2019re searching for a minimum, just flip the comparison:   <code>if f(mid1) &gt; f(mid2): low = mid1 else: high = mid2</code></li> <li>Precision controlled by <code>eps</code></li> </ul>"},{"location":"Data%20Science/DSA/tries.html","title":"Tries","text":"<p>29.10.2025 Retrieval data structure (means to fetch), others say the name comes from the word tree.</p> <ul> <li>Also known as prefix tree</li> <li>A tree-like data structure that stores a dynamic set of strings, where the keys are usually strings.</li> <li>Each node represents a single character of a string.</li> <li>The root node represents an empty string.</li> <li>Each path from the root to a leaf node represents a complete string.</li> <li>Commonly used for tasks such as autocomplete, spell checking, and IP routing.</li> </ul> <p></p>"},{"location":"Data%20Science/DSA/tries.html#architecture","title":"Architecture","text":""},{"location":"Data%20Science/DSA/tries.html#trie-node","title":"Trie Node","text":"<ul> <li>Each node contains an array or a map of child nodes, where each child node corresponds to a character in the alphabet.</li> <li>For example, in a trie for lowercase English letters, each node would have up to 26 children and therefore an array of size 26.</li> <li>A boolean flag is often used to indicate whether a node represents the end of a valid string.</li> <li>The node does not store the character itself; instead, the position of the node in the trie determines the character it represents.</li> </ul> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26  # Assuming only lowercase English letters\n        self.is_end_of_word = False\n</code></pre>"},{"location":"Data%20Science/DSA/tries.html#trie-root","title":"Trie Root","text":"<ul> <li>The root node is the starting point of the trie and does not contain any character.</li> <li>It only has child nodes.</li> </ul>"},{"location":"Data%20Science/DSA/tries.html#basic-operations","title":"Basic Operations","text":""},{"location":"Data%20Science/DSA/tries.html#insertion","title":"Insertion","text":"<ul> <li>To insert a string into the trie, start at the root node and for each character in the string, check if a child node exists for that character.</li> <li>If it does not exist, create a new child node.</li> <li>Move to the child node and repeat the process for the next character.</li> <li>After inserting all characters, mark the last node's boolean flag to indicate the end of a valid string.</li> <li>Time Complexity: O(m), where m is the length of the string being inserted.</li> <li>Space Complexity: O(m) in the worst case, when all characters are unique.</li> </ul> <pre><code>def insert(word):\n    node = root\n    for char in word:\n        index = ord(char) - ord('a')  # Assuming only lowercase English letters\n        if not node.children[index]:    # If the child node is null\n            node.children[index] = TrieNode()\n        node = node.children[index]\n    node.is_end_of_word = True\n</code></pre>"},{"location":"Data%20Science/DSA/tries.html#searching-a-string","title":"Searching (a String)","text":"<ul> <li>To search for a string in the trie, start at the root node and for each character in the string, check if a child node exists for that character.</li> <li>If a child node does not exist, the string is not present in the trie.</li> <li>If all characters are found, check the boolean flag of the last node to determine if it represents the end of a valid string.</li> <li>Time Complexity: O(m), where m is the length of the string being searched.</li> <li>Space Complexity: O(1)</li> </ul> <pre><code>def search(word):\n    node = root\n    for char in word:\n        index = ord(char) - ord('a')\n        if not node.children[index]:        # If the child node is null\n            return False                    # Return false\n        node = node.children[index]\n    return node.is_end_of_word              # Return true if your last letter is the end of a valid word\n</code></pre>"},{"location":"Data%20Science/DSA/tries.html#prefix-searching","title":"Prefix Searching","text":"<ul> <li>To check if any string in the trie starts with a given prefix</li> <li>Works similarly to the search operation, but does not require checking the boolean flag at the end.</li> <li>Time Complexity: O(m), where m is the length of the prefix being searched.</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"Data%20Science/DSA/tries.html#delete","title":"Delete","text":"<ul> <li>Case 1: The string to be deleted is not present in the trie.</li> <li>Case 2: The string has no other words sharing its prefix.</li> <li>Case 3: The string is a prefix of another word.</li> <li>set the <code>is_end_of_word</code> flag to <code>False</code>.</li> <li>Case 4: The string shares a prefix with other words but is not a prefix itself.</li> <li>Delete all nodes up to the point where the prefix is shared.</li> <li>Case 5 : The string shares a letter with other words.</li> <li>Only delete nodes under the one that is shared.</li> <li>Time Complexity: O(m), where m is the length of the string being deleted.</li> <li>Space Complexity: O(m), where m is the length of the string being deleted (for the stack).</li> </ul> <pre><code>def delete(word):\n    node = root\n    stack = []                          # To keep track of nodes for backtracking\n    for char in word:\n        index = ord(char) - ord('a')\n        if not node.children[index]:\n            return                      # Word not found\n        stack.append((node, index))     # Store the parent node (where you come from) and index (which child of the parent)\n        node = node.children[index]\n    if not node.is_end_of_word:\n        return                          # Word not found\n    node.is_end_of_word = False         # Unmark the end of word\n    # Backtrack and delete nodes if they are no longer needed\n    if any(node.children):\n        return                          # If the node has children, do not delete\n    for parent, index in reversed(stack):\n        parent.children[index] = None   # Delete the child node\n        if parent.is_end_of_word or any(parent.children):\n            break                        # Stop if the parent is end of another word or has other children\n        node = parent                    # Move up to the parent, so root is allways the one you are looking at\n</code></pre>"},{"location":"Data%20Science/DSA/tries.html#iteration","title":"Iteration","text":"<ul> <li>???</li> </ul>"},{"location":"Data%20Science/Notes/index.html","title":"General Notes","text":"<ul> <li>Project ideas</li> </ul>"},{"location":"Data%20Science/Notes/project_ideas.html","title":"Project Ideas","text":""},{"location":"Data%20Science/Notes/project_ideas.html#data-structures-algorithms","title":"Data Structures &amp; Algorithms","text":""},{"location":"Data%20Science/Notes/project_ideas.html#building-a-crossword-puzzle-game","title":"Building a crossword puzzle game","text":"<p>(https://github.com/HartasCuerdas/xwHelper) Difficulty level: Medium  Crossword puzzle games are often liked by children, and even parents allow them to play them to improve their vocabulary and language skills. This program will train students to build a crossword puzzle game that can generate and solve various puzzles. It will take a list of words, generate a crossword grid, and place the words in an interlocking pattern. It will also help users find and fill in the missing words depending on clues and the interlocking pattern of the grid.  Learning outcomes: Learn multiple data structures and algorithms related to string manipulation, search techniques, and pattern matching Use data structures like hash tables for storing and manipulating word lists Implementing backtracking algorithms or constraint satisfaction techniques to generate and solve different crossword puzzles Designing a user-friendly interface for users to interact with the system  What it takes to execute this project: - Use a 2D array or matrix to represent the crossword puzzle grid. - Implement a trie or prefix tree data structure to store and search for words efficiently. - Utilize backtracking algorithms to find valid word placements in the grid. - Implement constraint satisfaction techniques to ensure word intersections and grid validity. - Use heuristics or scoring functions to guide the search process and optimize solutions. - Integrate randomization algorithms for puzzle generation and variation. - Implement data structures like stacks or queues for undo/redo functionality. - Provide a user interface for displaying the puzzle, entering words, and interacting with game features. - Handle input validation, error checking, and scoring mechanisms for gameplay. Real-world application: Play schools: They can use this tool for building vocabulary and language skills among children  E-commerce platforms: They can implement such games to attract customers to their platform and let them win cashback or discount coupons  Publishing houses: Newspapers and magazines often print crossword puzzles for readers to improve their vocabulary, and with this tool, creating new puzzles regularly becomes easy</p>"},{"location":"Data%20Science/Notes/project_ideas.html#plagiarism-detection-system","title":"Plagiarism detection system","text":"<p>(https://github.com/xryuseix/SA-Plag) Difficulty level: Medium Writers face difficulty in detecting plagiarism in their work, which leads to legal issues at times. This tool will help you analyze documents, implement algorithms to compare them with other text documents, and detect similarities within them.  Learning outcomes: - Implementing string-matching algorithms for the identification of plagiarism  -  Use of data structures like hash tables to store and manipulate data for comparison  - Optimizing algorithms to handle large volumes of text data efficiently  - Gain knowledge of data preprocessing, text normalization, and handling large datasets What it takes to execute this project: - Use a data structure like a hash table or trie to store and index document text. - Implement algorithms for text preprocessing (tokenization, stemming, stop word removal). - Utilize string matching algorithms (e.g., Knuth-Morris-Pratt, Boyer-Moore) for finding plagiarized text segments. - Implement similarity measures like cosine similarity, Jaccard index, or n-gram matching. - Use clustering algorithms (e.g., k-means, hierarchical) to group similar documents. - Implement efficient data structures (e.g., suffix arrays, suffix trees) for pattern matching. - Handle large document collections using techniques like shingling or locality-sensitive hashing. - Provide a user interface for uploading documents and displaying plagiarism detection results. - Integrate with external document sources or databases for comprehensive checking. Real-world application: Educational institutions: They can use this application to look into academic papers and students\u2019 assignments to detect plagiarism  Publishing house:These houses need to publish articles and videos, and they can use the application to ensure the content is free from plagiarism  Content creators: Content creators need to check for plagiarism in their content before submitting it to clients or releasing it on different platforms, and therefore, this application is useful for them Legal house: Lawyers use this application to analyze contracts, patents, or other legal documents for plagiarism or intellectual property violations </p>"},{"location":"Data%20Science/Notes/project_ideas.html#travel-planner-using-graph","title":"Travel planner using Graph","text":"<p>(https://github.com/Nirespire/Dijkstra-Travel-Planner) Difficulty level: Medium This project aims to help travelers plan optimal travel routes between different locations. It uses graph data structures to represent locations as nodes and paths and the connecting roads or transportation routes as edges. This application will be able to calculate the shortest path between two locations, considering factors like distance, travel time, and cost. Learning outcomes: - Hands-on experience in working with graph data structures and algorithms  - Learn different types of graphs like directed, undirected, and weighted graphs - How to represent and traverse graphs using techniques like adjacency lists or matrices - Implement graph algorithms like Dijkstra\u2019s algorithm, DFS (Depth-First-Search), and BFS (Breadth-First-Search) to find the shortest path between two locations  - Develop skills in data handling, input/output operations, and user interface design What it takes to execute this project: - Represent locations as nodes in a graph data structure, with edges representing travel routes. - Assign weights to edges based on distance, travel time, or cost. - Implement graph traversal algorithms like depth-first search (DFS) or breadth-first search (BFS) to find possible routes. - Use shortest path algorithms like Dijkstra\u2019s or A to find optimal routes based on distance/time/cost. - Implement data structures like priority queues or heaps for efficient path-finding. - Handle constraints like budget, travel mode, or stopover preferences. - Integrate with external APIs for fetching location data, travel information, or real-time updates. - Provide a user interface for entering source, destination, and preferences, and displaying planned routes. Real world application: Navigation systems: Navigation systems like GPS devices and maps can implement this application to find the best roads for travelers and drivers  Logistics and supply chain industry: They can use such systems to optimize their delivery routes for trucks to reduce cost and improve delivery time Travel agencies:* These organizations can provide better services by planning efficient travel roads for clients considering different constraints with this application</p>"},{"location":"schule/index.html","title":"Schule","text":"<ul> <li>Netzwerktechnik</li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/index.html","title":"Index von Objekt-Orientierter-Programmierung","text":""},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html","title":"UML-Diagramme: Use Case &amp; Struktogramme","text":""},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#01112025","title":"01.11.2025","text":"<p>Dieses Dokument behandelt zwei wichtige Arten von Diagrammen zur Visualisierung von Systemen und Programmen:  </p> <ol> <li>Use Case Diagramme \u2013 zeigen Interaktionen zwischen Akteuren und Systemfunktionen  </li> <li>Struktogramme (Nassi-Shneiderman-Diagramme) \u2013 zeigen die logische Struktur von Algorithmen  </li> </ol>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#use-case-diagramme","title":"Use Case Diagramme","text":"<ul> <li>Ein Use Case Diagramm zeigt die Interaktionen zwischen Benutzern (Akteuren) und einem System </li> <li>Bestandteil der UML (Unified Modeling Language)  </li> <li>Ziel: die Funktionalit\u00e4t und Anforderungen eines Systems \u00fcbersichtlich darstellen  </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#bestandteile","title":"Bestandteile","text":"<ul> <li>Akteure (Actors): Personen, Organisationen oder externe Systeme, die mit dem System interagieren  </li> <li>Use Cases: Funktionale Anforderungen oder Aktionen des Systems  </li> <li>Beziehungen: </li> <li>Assoziation: Verbindung zwischen Akteur und Use Case  </li> <li>Include: Ein Use Case wird immer von einem anderen verwendet  </li> <li>Extend: Ein Use Case wird optional von einem anderen erweitert  </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#beispiel","title":"Beispiel","text":"<p>bild fehlt</p> <ul> <li>Akteur: \u201eBenutzer\u201c  </li> <li>Use Cases: \u201eLogin\u201c, \u201eDaten anzeigen\u201c, \u201eBericht erstellen\u201c  </li> <li>Beziehungen: \u201eLogin\u201c \u2192 include \u201eAuthentifizierung\u201c  </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#vorteile","title":"Vorteile","text":"<ul> <li>Klare \u00dcbersicht \u00fcber Systemfunktionalit\u00e4t </li> <li>Hilft bei der Kommunikation zwischen Entwicklern und Stakeholdern </li> <li>Unterst\u00fctzt die Anforderungsanalyse </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#struktogramme-nassi-shneiderman-diagramme","title":"Struktogramme (Nassi-Shneiderman-Diagramme)","text":"<ul> <li>Ein Struktogramm ist eine grafische Darstellung von Algorithmen </li> <li>Zeigt kontrollflussorientiert, wie ein Programm aufgebaut ist  </li> <li>Ziel: logische Struktur eines Programms verst\u00e4ndlich darstellen </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#bestandteile_1","title":"Bestandteile","text":"<ul> <li>Sequenz: Schritte werden untereinander ausgef\u00fchrt  </li> <li>Verzweigung (If-Else): Entscheidungen durch geteilt K\u00e4sten </li> <li>Schleifen: Wiederholungen (For, While) als K\u00e4sten mit Bedingung </li> <li>Unterprogramme/Funktionen: Eingeklappte K\u00e4sten oder spezielle Symbole  </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#beispiel_1","title":"Beispiel","text":"<p>bild fehlt</p> <ul> <li>Ablauf:  </li> <li>Eingabe einer Zahl  </li> <li>Pr\u00fcfen, ob Zahl &gt; 0  <ul> <li>Ja \u2192 \u201ePositive Zahl\u201c ausgeben  </li> <li>Nein \u2192 \u201eNicht-positive Zahl\u201c ausgeben  </li> </ul> </li> <li>Ende  </li> </ul>"},{"location":"schule/Objekt-Orientierte%20Programmierung/diagramme.html#vorteile_1","title":"Vorteile","text":"<ul> <li>Klare Darstellung der Programmstruktur </li> <li>Einfaches Debugging und Verst\u00e4ndnis komplexer Algorithmen  </li> <li>Grundlage f\u00fcr Programmierlogik und Pseudocode</li> </ul>"},{"location":"schule/netzwerktechnik/index.html","title":"Netzwerktechnik mit Filius","text":""},{"location":"schule/netzwerktechnik/index.html#fragen","title":"Fragen:","text":"<ul> <li>Weiterleitungstabellen (Aufgabe 22a/Seite 27 im Skript)</li> </ul>"},{"location":"schule/netzwerktechnik/index.html#basic-commands","title":"Basic Commands","text":"<ul> <li><code>ping 192.168.0.10</code>: Testet die Erreichbarkeit eines Hosts im Netzwerk und misst die Antwortzeit.</li> <li><code>ipconfig</code>: Zeigt die aktuelle IP-Konfiguration des Computers an, einschlie\u00dflich IP-Adresse, Subnetzmaske und Standardgateway.</li> </ul>"},{"location":"schule/netzwerktechnik/index.html#ip-adressen","title":"IP-Adressen","text":""},{"location":"schule/netzwerktechnik/index.html#echo-server-und-einfacher-client","title":"Echo-Server und Einfacher Client","text":""},{"location":"schule/netzwerktechnik/index.html#_1","title":"Netzwerktechnik mit Filius","text":""},{"location":"schule/netzwerktechnik/index.html#vermittlungsrechner","title":"Vermittlungsrechner","text":"<ul> <li>verbindet verschiedene Netzwerke und leitet Datenpakete weiter.</li> <li>die Netzwerke m\u00fcssen unterschiedliche IP-Adressbereiche haben. Also unterschiedliche Gateways.</li> </ul>"},{"location":"schule/netzwerktechnik/index.html#gateway","title":"Gateway","text":"<ul> <li>Ein Gateway ist ein Knotenpunkt, der als Zugangspunkt zu einem anderen Netzwerk dient.</li> <li>Gatewayname ist meist die IP-Adresse des Routers im lokalen Netzwerk.</li> <li><code>IP-Adresse: 192.168.0.10, Gateway: 192.168.0.1</code></li> </ul>"},{"location":"schule/netzwerktechnik/index.html#dns-server","title":"DNS-Server","text":"<ul> <li>Ein DNS-Server (Domain Name System) \u00fcbersetzt Domainnamen (z.B. www.beispiel.de) in IP-Adressen</li> <li>Beispiel: <code>www.beispiel.de</code> wird in <code>192.168.0.10</code> umgewandelt.</li> </ul>"},{"location":"schule/netzwerktechnik/index.html#modem","title":"Modem","text":"<ul> <li>\u00fcber Modems kann man eine Verbindung \u00fcber internet zu einem anderen Netzwerk mit Modem herstellen.</li> <li>Man kann es sich vereinfacht wie ein Kabel vorstellen, genau wie bei einem Kabel muss das Gateway auf beiden Seiten gleich sein.</li> <li>Falls man zum Beispiel in Filius eine Verbindung \u00fcber ein Modem herstellen m\u00f6chte, dass auf dem selben Rechner liegt, reicht <code>IP-Adresse: localhost</code> </li> </ul>"},{"location":"schule/netzwerktechnik/index.html#peer-to-peer-p2p","title":"Peer-to-Peer (P2P)","text":"<p> - Client-Rechner die im selben Netzwerk sind, k\u00f6nnen direkt miteinander kommunizieren. - Es wird kein Vermittlungsrechner ben\u00f6tigt. - In Filius k\u00f6nnen Peer-to-Peer Verbindungen \u00fcber die Software Gnutella auf den Rchnern simuliert werden.</p>"},{"location":"schule/netzwerktechnik/index.html#dhcp","title":"DHCP","text":"<ul> <li>kurz f\u00fcr Dynamic Host Configuration Protocol</li> <li>Verteilt automatisch IP-Adressen an Ger\u00e4te in einem Netzwerk.</li> <li>Praktisch in gro\u00dfen Netzwerken, die un\u00fcbersichtlich werden k\u00f6nnen</li> <li>Verhindert IP-Adresskonflikte, da jede Adresse nur einmal vergeben wird.</li> <li>Start und Ende des IP-Adressbereichs wird im DHCP-Server festgelegt.<ul> <li>Der Server hat dann als IP-Adresse z.B. den Startwert.</li> <li>Die anderen clients bekommen dann automatisch die aufsteigenden IP-Adresse aus dem Bereich zugewiesen.</li> </ul> </li> </ul>"},{"location":"schule/netzwerktechnik/index.html#manuelles-routing","title":"Manuelles Routing","text":"<p> - Routing \u00fcber mehrere Vermittlungsrechner - Filius gibt die M\u00f6glichkeit, Automatisches Routing zu aktivieren. - Alternativ kann man auch Manuelles Routing verwenden. - Daf\u00fcr sind auf jedem Rechner die Routen zu den anderen Netzwerken einzeln einzutragen, in Weiterleitungstabellen dargestellt.</p>"},{"location":"schule/netzwerktechnik/index.html#protokolle-arp-vs-icmp-vs-smtp-server-u-port-vs-tcp-usw","title":"Protokolle (ARP vs. ICMP vs. SMTP (Server u. Port) vs.  TCP usw.)","text":""},{"location":"schule/netzwerktechnik/index.html#mail-pop3-etc","title":"Mail (POP3 etc.)","text":""},{"location":"schule/netzwerktechnik/index.html#mac","title":"MAC","text":""},{"location":"schule/netzwerktechnik/index.html#tcpip-modell-hat-osi-schicht-modell-abgelost","title":"TCP/IP Modell hat OSI-Schicht-Modell abgel\u00f6st","text":""},{"location":"schule/netzwerktechnik/index.html#weitere-funktionen-von-filius","title":"Weitere Funktionen von Filius","text":"<ul> <li>Eigene Software erstellen und einbinden<ul> <li>Filius bietet die M\u00f6glichkeit, eigene Software zu programmieren und in die Simulation zu integrieren.</li> <li>Filius h\u00e4lt daf\u00fcr einen Assistenten bereit, der bei der Erstellung und Einbindung eigener Software hilft.</li> </ul> </li> </ul>"},{"location":"schule/netzwerktechnik/index.html#termine","title":"Termine","text":"<p>03.11.-17.11. pr\u00e4si vorbereiten 24.11. vorstellung 01.12. Aufgaben 08.12. Klausur</p>"},{"location":"schule/netzwerktechnik/ip_adressen.html","title":"IP-Adressen","text":""},{"location":"schule/netzwerktechnik/ip_adressen.html#aufbau-einer-ip-adresse","title":"Aufbau einer IP-Adresse","text":"<ul> <li>nach der derzeitig g\u00fcltigen IP-Version 4 (IPv4)</li> <li>32 Bit, in 4 Bl\u00f6cken mit je 8 bit, die durch einen Punkt getrennt sind und als Dezimalzahlen dargestellt werden.<ul> <li>Beispiel: <code>192.168.0.10</code></li> </ul> </li> <li>Es sind werte von <code>0.0.0.0</code> bis <code>255.255.255.255</code> m\u00f6glich.</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#subnetzmaske","title":"Subnetzmaske:","text":"<ul> <li>trennt die IP-Adresse in Netzwerkteil und Ger\u00e4teteil</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#netzwerkteilnetzwerkadresse","title":"Netzwerkteil/Netzwerkadresse:","text":"<ul> <li>UND-Verkn\u00fcpfung von IP-Adresse und Subnetzmaske</li> <li>Adresse des gesamten Netzwerks</li> <li>kleinste Adresse im IP-Adressbereich</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#gerateteilhost-adresse","title":"Ger\u00e4teteil/Host-Adresse:","text":"<ul> <li>Vereinfacht: Wievieltes Ger\u00e4t im Netzwerk ist es?</li> <li>UND-Verkn\u00fcpfung von IP-Adresse und invertierten Subnetzmaske</li> <li>Adressen der einzelnen Ger\u00e4te im Netzwerk</li> <li>mittlere Adressen im IP-Adressbereich/exclusive Netzwerk- und Broadcastadresse</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#broadcastadresse","title":"Broadcastadresse:","text":"<ul> <li>Adresse um Nachrichten an alle Mitglieder im Netzwerk zu schicken</li> <li>gr\u00f6\u00dfte Adresse im IP-Adressbereich</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#ip-adressbereich","title":"IP-Adressbereich:","text":"<ul> <li>Bereich von IP-Adressen, die in einem Netzwerk verwendet werden k\u00f6nnen.</li> <li>Die Subnetzmaske legt den IP-Adressbereich fest. Es sind soviel Bits (in Bin\u00e4r darstellung) f\u00fcr den Netzwerkteil gesetzt, wie die Subnetzmaske Einsen hat. Danach folgen die Bits f\u00fcr den Ger\u00e4teteil, die ver\u00e4nderbar sind.</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#default-gateway","title":"Default-Gateway:","text":"<ul> <li>Erste Adresse im IP-Adressbereich</li> </ul>"},{"location":"schule/netzwerktechnik/ip_adressen.html#beispiel","title":"Beispiel:","text":"<pre><code>- IP-Adresse: `192.145.96.201 = (...).11001001`\n- Subnetzmaske: `255.255.255.128 = 1111111.11111111.11111111.10000000` \n- Netzwerkteil: 25 Bits \n- Netzwerkadresse: `192.145.96.128`\n- Ger\u00e4teteil: `1001001 = 73` (letzte 7 Bits)\n- IP-Adressbereich: `192.145.96.128 = (...).10000000` bis `192.145.96.254 = (...).11111111`\n    - die letzten 7 Bits k\u00f6nnen ver\u00e4ndert werden, sie sind der Ger\u00e4teteil\n- Broadcastadresse: `192.145.96.255`\n- Default-Gateway: `192.145.96.129`\n</code></pre>"},{"location":"schule/netzwerktechnik/weiterleitungstabellen.html","title":"Weiterleitungstabellen","text":"Ziel Netzmaske N\u00e4chstes Gateway Schnittstelle"}]}